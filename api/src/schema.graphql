type Member {
  id: ID!
  auth_id: String
  firstName: String #@search
  middleName: String
  lastName: String
  fullName: String @ignore
  email: String
  phoneNumber: String
  whatsappNumber: String
  pictureUrl: String
  gender: Gender @relationship(type: "HAS_GENDER", direction: OUT)
  maritalStatus: MaritalStatus
    @relationship(type: "HAS_MARITAL_STATUS", direction: OUT)
  dob: TimeGraph @relationship(type: "WAS_BORN_ON", direction: OUT)
  title: [Title]
    @relationship(type: "HAS_TITLE", properties: "HasTitle", direction: OUT)
  ministry: Ministry @relationship(type: "BELONGS_TO", direction: OUT)
  occupation: Occupation @relationship(type: "HAS_OCCUPATION", direction: OUT)
  # Church Details
  history: [HistoryLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  loggedHistory: [HistoryLog] @relationship(type: "LOGGED_BY", direction: IN)
  bacenta: Bacenta @relationship(type: "BELONGS_TO", direction: OUT)
  bishop: Member
    @cypher(
      statement: """
      MATCH (this)
      OPTIONAL MATCH (this)-[:BELONGS_TO]->(:Bacenta)<-[:HAS_BACENTA]-(:Centre)<-[:HAS_CENTRE]-()-[:HAS_CAMPUS|:HAS_TOWN]-(bishopFromBacenta:Member)
      OPTIONAL MATCH (this)-[:IS_ADMIN_FOR]-(bishopFromAdmin:Member)
      OPTIONAL MATCH (this)-[:IS_ADMIN_FOR]->()<-[:HAS_TOWN|:HAS_CAMPUS]-(bishopFromConAdmin:Member)
      OPTIONAL MATCH (this)-[:LEADS]-()<-[:HAS_TOWN|:HAS_CAMPUS]-(bishopFromCO:Member)
      OPTIONAL MATCH (this)-[:LEADS]-(:Centre)<-[:HAS_CENTRE]-()<-[:HAS_TOWN|:HAS_CAMPUS]-(bishopFromCentreLeader:Member)
      OPTIONAL MATCH (this)-[:LEADS]-(:Bacenta)<-[:HAS_BACENTA]-(:Centre)<-[:HAS_CENTRE]-()<-[:HAS_TOWN|:HAS_CAMPUS]-(bishopFromBacentaLeader:Member)
      UNWIND [bishopFromBacenta,bishopFromAdmin,bishopFromConAdmin,bishopFromCO,bishopFromCentreLeader,bishopFromBacentaLeader] as bishop
      WITH bishop WHERE bishop IS NOT NULL
      RETURN DISTINCT bishop
      """
    )
  bacentas(search: String): [Bacenta]
    @cypher(
      statement: """
      MATCH (this)
      OPTIONAL MATCH (this)-[:HAS_CAMPUS|HAS_TOWN]->()-[:HAS_CENTRE]->(centre:Centre)
      OPTIONAL MATCH (centre)-[:HAS_BACENTA]-(bacenta)
      WHERE toLower(bacenta.name) CONTAINS toLower($search)
      WITH bacenta WHERE bacenta IS NOT NULL
      RETURN bacenta LIMIT 8
      """
    )
  centres(search: String): [Centre]
    @cypher(
      statement: """
      MATCH (this)
      OPTIONAL MATCH (this)-[:HAS_CAMPUS|HAS_TOWN]->()-[:HAS_CENTRE]->(centre:Centre)
      WHERE toLower(centre.name) CONTAINS toLower($search)
      WITH centre WHERE centre IS NOT NULL
      RETURN centre
      """
    )
  leadsBacenta: [Bacenta] @relationship(type: "LEADS", direction: OUT)
  leadsCentre: [Centre] @relationship(type: "LEADS", direction: OUT)
  leadsMinistry: [Ministry] @relationship(type: "LEADS", direction: OUT)
  leadsSonta: [Sonta] @relationship(type: "LEADS", direction: OUT)
  leadsBasonta: [Basonta] @relationship(type: "LEADS", direction: OUT)
  leadsTown: [Town] @relationship(type: "LEADS", direction: OUT)
  leadsCampus: [Campus] @relationship(type: "LEADS", direction: OUT)
  isBishopForTown: [Town] @relationship(type: "HAS_TOWN", direction: OUT)
  isBishopForCampus: [Campus] @relationship(type: "HAS_CAMPUS", direction: OUT)
  isAdminForBishop: [Member] @relationship(type: "IS_ADMIN_FOR", direction: OUT) #@neo4j_ignore
  isAdminForCampus: [Campus] @relationship(type: "IS_ADMIN_FOR", direction: OUT)
  isAdminForTown: [Town] @relationship(type: "IS_ADMIN_FOR", direction: OUT)
  admin: Member @relationship(type: "IS_ADMIN_FOR", direction: IN)

  #Members
  members(nameSearch: String): [Member]
    @cypher(
      statement: """
      MATCH (this)-[:HAS_TOWN|:HAS_CAMPUS]->(campusTown)
      MATCH (campusTown)-[:HAS_CENTRE]->(centre)
      MATCH (centre)-[:HAS_BACENTA]->(bacenta:Bacenta)
      OPTIONAL MATCH (bacenta)<-[:BELONGS_TO*]-(member:Member)
      OPTIONAL MATCH (bacenta)<-[:LEADS]-(bacentaLeader:Member)
      OPTIONAL MATCH (centre)<-[:LEADS]-(centreLeader:Member)
      OPTIONAL MATCH (campusTown)<-[:LEADS]-(constituencyOverseer:Member)
      OPTIONAL MATCH (this)<-[:IS_ADMIN_FOR]-(admin:Member)
      OPTIONAL MATCH (campusTown)<-[:IS_ADMIN_FOR]-(adminConstituency:Member)
      UNWIND [member,bacentaLeader,centreLeader,constituencyOverseer,admin,adminConstituency] as members

      WITH members WHERE members IS NOT NULL

      RETURN DISTINCT members ORDER BY members.firstName
      """
    )

  #OTHER WORKS
  was_treasurer_for: [ServiceRecord]!
    @relationship(type: "WAS_TREASURER_FOR", direction: OUT)
}

extend type Member @auth(rules: [{ isAuthenticated: true }])
extend type Bacenta @auth(rules: [{ isAuthenticated: true }])
extend type Centre @auth(rules: [{ isAuthenticated: true }])
extend type Campus @auth(rules: [{ isAuthenticated: true }])
extend type Town @auth(rules: [{ isAuthenticated: true }])
extend type Sonta @auth(rules: [{ isAuthenticated: true }])
extend type Ministry @auth(rules: [{ isAuthenticated: true }])

type Gender @auth(rules: [{ isAuthenticated: true }]) {
  gender: String
  members: [Member] @relationship(type: "HAS_GENDER", direction: IN)
}

type MaritalStatus @auth(rules: [{ isAuthenticated: true }]) {
  status: String
  members: [Member] @relationship(type: "HAS_MARITAL_STATUS", direction: IN)
}

type Occupation @auth(rules: [{ isAuthenticated: true }]) {
  occupation: String
  members: [Member] @relationship(type: "HAS_OCCUPATION", direction: IN)
}

type Title @auth(rules: [{ isAuthenticated: true }]) {
  title: String! #Pastor, Reverend, Apostle, Bishop (Mother)
  members: [Member]
    @relationship(type: "HAS_TITLE", properties: "HasTitle", direction: IN)
}

interface HasTitle @relationshipProperties {
  dateAppointed: Date
}

type TimeGraph @auth(rules: [{ isAuthenticated: true }]) {
  date: Date
  memberDob: Member @relationship(type: "WAS_BORN_ON", direction: IN)
  # titleAppointmentDate: Member @relationship(type: "APPOINTED_ON", direction: IN)
  leaderHistoryStartDate: Member
    @relationship(type: "LEADER_STARTED_ON", direction: OUT)
  leaderHistoryEndDate: TimeGraph
    @relationship(type: "LEADER_ENDED_ON", direction: OUT)
  historyDate: Member @relationship(type: "RECORDED_ON", direction: OUT)
  serviceDate: [ServiceRecord]
    @relationship(type: "SERVICE_HELD_ON", direction: IN)
}

type ServiceRecord @auth(rules: [{ isAuthenticated: true }]) {
  id: ID!
  created_at: Date
  created_by: Member @relationship(type: "LOGGED_BY", direction: OUT)
  serviceDate: TimeGraph @relationship(type: "SERVICE_HELD_ON", direction: OUT)
  week: Int
    @cypher(
      statement: """
      MATCH (this)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      RETURN date(date.date).week
      """
    )
  attendance: Int
  income: Float
  foreignCurrency: String
  servicePicture: String
  treasurerSelfie: String
  treasurers: [Member]! @relationship(type: "WAS_TREASURER_FOR", direction: IN)
  historyLog: HistoryLog @relationship(type: "HAS_RECORD", direction: IN)
  noServiceReason: String
}

type NoService @auth(rules: [{ isAuthenticated: true }]) {
  id: ID!
  created_at: Date
  created_by: Member @relationship(type: "LOGGED_BY", direction: OUT)
  serviceDate: TimeGraph @relationship(type: "SERVICE_HELD_ON", direction: OUT)
  week: Int
    @cypher(
      statement: """
      MATCH (this)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      RETURN date(date.date).week
      """
    )
  historyLog: HistoryLog @relationship(type: "HAS_RECORD", direction: IN)
  noServiceReason: String
}

type ServiceLog @auth(rules: [{ isAuthenticated: true }]) {
  id: ID
  historyRecord: String #leader was transferred to
  created_at: TimeGraph @relationship(type: "RECORDED_ON", direction: OUT)
  loggedBy: Member @relationship(type: "LOGGED_BY", direction: OUT)
  serviceRecords: [ServiceRecord]
    @relationship(type: "HAS_RECORD", direction: OUT)
  leaders: [Member] @relationship(type: "HAS_HISTORY", direction: IN)
  bacenta: [Bacenta] @relationship(type: "HAS_HISTORY", direction: IN)
  centre: [Centre] @relationship(type: "HAS_HISTORY", direction: IN)
  # centreBacentaRecords(centreId: ID!): [CentreBacentaServiceRecords]
  campus: [Campus] @relationship(type: "HAS_HISTORY", direction: IN)
  town: [Town] @relationship(type: "HAS_HISTORY", direction: IN)
  sonta: [Sonta] @relationship(type: "HAS_HISTORY", direction: IN)
}

type ComponentServiceAggregate {
  week: Int!
  attendance: Int!
  income: Float!
}

type HistoryLog @auth(rules: [{ isAuthenticated: true }]) {
  id: ID @id
  timeStamp: DateTime
  historyRecord: String #leader was transferred to
  created_at: TimeGraph @relationship(type: "RECORDED_ON", direction: OUT)
  loggedBy: Member @relationship(type: "LOGGED_BY", direction: OUT)
  leaders: [Member] @relationship(type: "HAS_HISTORY", direction: IN)
  bacenta: [Bacenta] @relationship(type: "HAS_HISTORY", direction: IN)
  centre: [Centre] @relationship(type: "HAS_HISTORY", direction: IN)
  campus: [Campus] @relationship(type: "HAS_HISTORY", direction: IN)
  town: [Town] @relationship(type: "HAS_HISTORY", direction: IN)
  sonta: [Sonta] @relationship(type: "HAS_HISTORY", direction: IN)
}

# Campus-Centre, Town-Centre
type Constituency {
  id: ID @id
  name: String
  members: [Member]
    @cypher(
      statement: """
      MATCH (this)-[:HAS_CENTRE]->(centre:Centre)-[:HAS_BACENTA]->(bacenta:Bacenta)
      OPTIONAL MATCH (bacenta)<-[:BELONGS_TO*]-(member:Member)
      OPTIONAL MATCH (bacenta)<-[:LEADS]-(bacentaLeader:Member)
      OPTIONAL MATCH (centre)<-[:LEADS]-(centreLeader:Member)
      OPTIONAL MATCH (this)<-[:LEADS]-(constituencyOverseer:Member)
       OPTIONAL MATCH (this)<-[:IS_ADMIN_FOR]-(adminConstituency:Member)
      UNWIND [member,bacentaLeader,centreLeader,constituencyOverseer,adminConstituency] as members
      WITH members WHERE members IS NOT NULL
      RETURN DISTINCT members ORDER BY members.firstName
      """
    )
  leader: Member @relationship(type: "LEADS", direction: IN)
  sontas: [Sonta] @relationship(type: "HAS_SONTA", direction: OUT)
  centres: [Centre] @relationship(type: "HAS_CENTRE", direction: OUT)
  campusBishop: Member @relationship(type: "HAS_CAMPUS", direction: IN)
  townBishop: Member @relationship(type: "HAS_TOWN", direction: IN)
  admin: Member @relationship(type: "IS_ADMIN_FOR", direction: IN)
  history: [HistoryLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  serviceRecord: [ServiceRecord]
    @relationship(type: "HAS_RECORD", direction: OUT)
  services: [ServiceLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  componentServiceAggregate: [ComponentServiceAggregate] @ignore
}

type Campus {
  id: ID @id
  name: String
  members: [Member]
    @cypher(
      statement: """
      MATCH (this)-[:HAS_CENTRE]->(centre:Centre)-[:HAS_BACENTA]->(bacenta:Bacenta)
      OPTIONAL MATCH (bacenta)<-[:BELONGS_TO*]-(member:Member)
      OPTIONAL MATCH (bacenta)<-[:LEADS]-(bacentaLeader:Member)
      OPTIONAL MATCH (centre)<-[:LEADS]-(centreLeader:Member)
      OPTIONAL MATCH (this)<-[:LEADS]-(constituencyOverseer:Member)
       OPTIONAL MATCH (this)<-[:IS_ADMIN_FOR]-(adminConstituency:Member)
      UNWIND [member,bacentaLeader,centreLeader,constituencyOverseer,adminConstituency] as members
      WITH members WHERE members IS NOT NULL
      RETURN DISTINCT members ORDER BY members.firstName
      """
    )
  leader: Member @relationship(type: "LEADS", direction: IN)
  sontas: [Sonta] @relationship(type: "HAS_SONTA", direction: OUT)
  centres: [Centre] @relationship(type: "HAS_CENTRE", direction: OUT)
  bishop: Member @relationship(type: "HAS_CAMPUS", direction: IN)
  admin: Member @relationship(type: "IS_ADMIN_FOR", direction: IN)
  history: [HistoryLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  serviceRecord: [ServiceRecord]
    @relationship(type: "HAS_RECORD", direction: OUT)
  services: [ServiceLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  componentServiceAggregate: [ComponentServiceAggregate] @ignore
}

type Town {
  id: ID @id
  name: String
  members: [Member]
    @cypher(
      statement: """
      MATCH (this)-[:HAS_CENTRE]->(centre:Centre)-[:HAS_BACENTA]->(bacenta:Bacenta)
      OPTIONAL MATCH (bacenta)<-[:BELONGS_TO*]-(member:Member)
      OPTIONAL MATCH (bacenta)<-[:LEADS]-(bacentaLeader:Member)
      OPTIONAL MATCH (centre)<-[:LEADS]-(centreLeader:Member)
      OPTIONAL MATCH (this)<-[:LEADS]-(constituencyOverseer:Member)
       OPTIONAL MATCH (this)<-[:IS_ADMIN_FOR]-(adminConstituency:Member)
      UNWIND [member,bacentaLeader,centreLeader,constituencyOverseer,adminConstituency] as members
      WITH members WHERE members IS NOT NULL
      RETURN DISTINCT members ORDER BY members.firstName
      """
    )
  leader: Member @relationship(type: "LEADS", direction: IN)
  sontas: [Sonta] @relationship(type: "HAS_SONTA", direction: OUT)
  centres: [Centre] @relationship(type: "HAS_CENTRE", direction: OUT)
  bishop: Member @relationship(type: "HAS_TOWN", direction: IN)
  admin: Member @relationship(type: "IS_ADMIN_FOR", direction: IN)
  history: [HistoryLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  serviceRecord: [ServiceRecord]
    @relationship(type: "HAS_RECORD", direction: OUT)
  services: [ServiceLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  componentServiceAggregate: [ComponentServiceAggregate] @ignore
}

type Centre {
  id: ID @id
  name: String
  members: [Member]
    @cypher(
      statement: """
      MATCH (this)-[:HAS_BACENTA]->(bacenta:Bacenta)
      OPTIONAL MATCH (bacenta)<-[:BELONGS_TO*]-(member:Member)
      OPTIONAL MATCH (bacenta)<-[:LEADS]-(bacentaLeader:Member)
      OPTIONAL MATCH (this)<-[:LEADS]-(centreLeader:Member)
      UNWIND [member,bacentaLeader,centreLeader] as members
      WITH members WHERE members IS NOT NULL
      RETURN DISTINCT members ORDER BY members.firstName
      """
    )
  leader: Member @relationship(type: "LEADS", direction: IN)
  bacentas: [Bacenta] @relationship(type: "HAS_BACENTA", direction: OUT)
  basontas: Basonta @relationship(type: "HAS_BASONTA", direction: OUT)
  town: Town @relationship(type: "HAS_CENTRE", direction: IN)
  campus: Campus @relationship(type: "HAS_CENTRE", direction: IN)
  history: [HistoryLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  services: [ServiceLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  bacentaServiceAggregate: [ComponentServiceAggregate] @ignore
}

# Shared Units: Bacenta, Bacenta, Sonta
type Bacenta {
  id: ID @id
  name: String
  location: Point
  centre: Centre @relationship(type: "HAS_BACENTA", direction: IN)
  leader: Member @relationship(type: "LEADS", direction: IN)
  members: [Member]
    @cypher(
      statement: """
      MATCH (this)
      OPTIONAL MATCH (this)<-[:BELONGS_TO*]-(member:Member)
      OPTIONAL MATCH (this)<-[:LEADS]-(bacentaLeader:Member)
      UNWIND [member,bacentaLeader] as members
      WITH members WHERE members IS NOT NULL
      RETURN DISTINCT members ORDER BY members.firstName
      """
    )
  meetingDay: ServiceDay @relationship(type: "MEETS_ON", direction: OUT)
  history: [HistoryLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  services: [ServiceLog] @relationship(type: "HAS_HISTORY", direction: OUT)
}

type ServiceDay @auth(rules: [{ isAuthenticated: true }]) {
  day: String!
  dayNum: Int
  bacenta: Bacenta @relationship(type: "MEETS_ON", direction: IN)
}

type Ministry {
  id: ID @id
  name: String
  sonta: [Sonta] @relationship(type: "HAS_SONTA", direction: OUT)
  leader: Member @relationship(type: "LEADS", direction: IN)
  members: [Member] @relationship(type: "BELONGS_TO", direction: IN)
}

type Sonta {
  id: ID @id
  name: String
  members: [Member]
    @cypher(
      statement: """
      MATCH (this)<-[:HAS_SONTA]-()-[:HAS_CENTRE]->()-[:HAS_BACENTA]->()<-[:BELONGS_TO]-(member:Member)
      MATCH (this)<-[:HAS_SONTA]-(ministry:Ministry)
      MATCH (member)-[:BELONGS_TO]->(ministry)
      RETURN member
      """
    )
  leader: Member @relationship(type: "LEADS", direction: IN)
  basonta: [Basonta] @relationship(type: "HAS_BASONTA", direction: OUT)
  ministry: Ministry @relationship(type: "HAS_SONTA", direction: IN)
  town: Town @relationship(type: "HAS_SONTA", direction: IN)
  history: [HistoryLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  campus: Campus @relationship(type: "HAS_SONTA", direction: IN)
  services: [ServiceLog] @relationship(type: "HAS_HISTORY", direction: OUT)
}
type Basonta {
  id: ID @id
  name: String
  leader: Member @relationship(type: "LEADS", direction: IN)
  centre: Centre @relationship(type: "HAS_BASONTA", direction: IN)
  sonta: Sonta @relationship(type: "HAS_BASONTA", direction: IN)
}

#Query Definitions
type Query {
  #At the Federal Level
  bishopsListCampus: [Member]
    @cypher(
      statement: "MATCH ()<-[:HAS_CAMPUS]-(bishop:Member) RETURN DISTINCT bishop"
    )
  bishopsListTown: [Member]
    @cypher(
      statement: "MATCH ()<-[:HAS_TOWN]-(bishop:Member) RETURN DISTINCT bishop"
    )
  memberCount: Int!
    @cypher(statement: "MATCH (member:Member) RETURN COUNT(DISTINCT member)")
  centreCount: Int!
    @cypher(statement: "MATCH (centre:Centre) RETURN COUNT(DISTINCT centre)")
  bacentaCount: Int!
    @cypher(
      statement: "MATCH (bacenta:Bacenta) RETURN COUNT( DISTINCT bacenta)"
    )
  federalPastorList(id: ID): [Member]
    @cypher(
      statement: "MATCH (:Title)<-[:HAS_TITLE]-(member:Member) RETURN member"
    )

  #At the Episcopal Level
  bishopCampusTownCount(id: ID): Int!
    @cypher(
      statement: "MATCH (:Member {id: $id})-[:HAS_TOWN|:HAS_CAMPUS]->(campusTown) WHERE campusTown:Campus OR campusTown:Town RETURN COUNT(DISTINCT campusTown)"
    )
  bishopCentreCount(id: ID): Int!
    @cypher(
      statement: "MATCH (:Member {id: $id})-[:HAS_TOWN|:HAS_CAMPUS]->()-[:HAS_CENTRE]-(centre) RETURN COUNT(DISTINCT centre)"
    )
  bishopBacentaCount(id: ID): Int!
    @cypher(
      statement: "MATCH (:Member {id: $id})-[:HAS_TOWN|:HAS_CAMPUS]->()-[:HAS_CENTRE]-()-[:HAS_BACENTA]-(bacenta) RETURN COUNT(DISTINCT bacenta)"
    )
  bishopBacentaDropdown(id: ID, bacentaName: String): [Bacenta]
    @cypher(
      statement: "MATCH (bacenta:Bacenta)<-[]-(:Centre)<-[:HAS_CENTRE]-()<-[:HAS_TOWN|:HAS_CAMPUS]-(:Member {id: $id}) WHERE toLower(bacenta.name) CONTAINS toLower($bacentaName) RETURN bacenta LIMIT 5"
    )
  bishopsSontaMemberList(id: ID): [Member]!
    @cypher(
      statement: """
      MATCH (:Member {id: $id})-[:HAS_TOWN|:HAS_CAMPUS]->()-[:HAS_CENTRE]->()-[:HAS_BACENTA]->()<-[:BELONGS_TO]-(member:Member)-[:BELONGS_TO]->(:Ministry)
      RETURN member
      """
    )
  bishopSontaMemberCount(id: ID): Int!
    @cypher(
      statement: """
      MATCH (:Member {id: $id})-[:HAS_TOWN|:HAS_CAMPUS]->()-[:HAS_CENTRE]->()-[:HAS_BACENTA]->()<-[:BELONGS_TO]-(member:Member)-[:BELONGS_TO]->(:Ministry)
      RETURN COUNT(DISTINCT member)
      """
    )
  bishopSontaMemberCountList(bishopId: ID): [Ministry]!
    @cypher(
      statement: """
      MATCH (:Member {id: $bishopId})-[:HAS_TOWN|:HAS_CAMPUS]->()-[:HAS_CENTRE]->()-[:HAS_BACENTA]->()<-[:BELONGS_TO]-(m:Member)-[:BELONGS_TO]->(ministry:Ministry)
      RETURN ministry, COUNT(DISTINCT member)
      """
    )
  bishopPastorCount(id: ID): Int!
    @cypher(
      statement: "MATCH (title:Title)<-[:HAS_TITLE]-(member:Member)-[:BELONGS_TO]->()<-[:HAS_BACENTA]-()-[:HAS_CENTRE]-()-[:HAS_TOWN|:HAS_CAMPUS]-(:Member {id: $id}) RETURN COUNT( DISTINCT member)"
    )
  bishopPastorList(id: ID): [Member]
    @cypher(
      statement: "MATCH (title:Title)<-[:HAS_TITLE]-(member:Member)-[:BELONGS_TO]->()<-[:HAS_BACENTA]-()<-[:HAS_CENTRE]-()<-[:HAS_TOWN|:HAS_CAMPUS]-(:Member {id: $id}) RETURN member"
    )
  bishopCentreDropdown(id: ID!, nameSearch: String!): [Centre]
    @cypher(
      statement: """
      MATCH (:Member {id: $id})-[:HAS_TOWN|:HAS_CAMPUS]->(campusTown)
      MATCH (campusTown)-[:HAS_CENTRE]->(centre)
      WHERE toLower(centre.name) CONTAINS toLower($nameSearch)
      RETURN centre LIMIT 5
      """
    )
  # bishopMemberList(id: ID): [Member]!
  #   @cypher(
  #     statement: """
  #     MATCH (bishop:Member {id: $id})-[:HAS_TOWN|:HAS_CAMPUS]->(campusTown)
  #     MATCH (campusTown)-[:HAS_CENTRE]->(centre)
  #     MATCH (centre)-[:HAS_BACENTA]->(bacenta)
  #     OPTIONAL MATCH (bacenta)<-[:BELONGS_TO*]-(member:Member)
  #     OPTIONAL MATCH (bacenta)<-[:LEADS]-(bacentaLeader:Member)
  #     OPTIONAL MATCH (centre)<-[:LEADS]-(centreLeader:Member)
  #     OPTIONAL MATCH (campusTown)<-[:LEADS]-(constituencyOverseer:Member)
  #     OPTIONAL MATCH (bishop)<-[:IS_ADMIN_FOR]-(admin:Member)
  #      OPTIONAL MATCH (campusTown)<-[:IS_ADMIN_FOR]-(adminConstituency:Member)
  #     UNWIND [member,bacentaLeader,centreLeader,constituencyOverseer,admin,adminConstituency] as members
  #     WITH members WHERE members IS NOT NULL
  #     RETURN DISTINCT members
  #     """
  #   )
  bishopMemberDropdown(id: ID, nameSearch: String): [Member]
    @cypher(
      statement: """
      MATCH (bishop:Member {id: $id})-[:HAS_CAMPUS|:HAS_TOWN]->(campusTown)-[:HAS_CENTRE]->(centre:Centre)-[:HAS_BACENTA]->(bacenta:Bacenta)
      OPTIONAL MATCH (bacenta)<-[:BELONGS_TO]-(member:Member)
      OPTIONAL MATCH (bacenta)<-[:LEADS]-(bacentaLeader:Member)
      OPTIONAL MATCH (centre)<-[:LEADS]-(centreLeader:Member)
      OPTIONAL MATCH (campusTown)<-[:LEADS]-(constituencyOverseer:Member)
      OPTIONAL MATCH (bishop)<-[:IS_ADMIN_FOR]-(admin:Member)
      OPTIONAL MATCH (campusTown)<-[:IS_ADMIN_FOR]-(adminConstituency:Member)
      UNWIND [member,bacentaLeader,centreLeader,constituencyOverseer,admin,adminConstituency] as members
      WITH members WHERE members IS NOT NULL
      AND toLower(members.firstName+ ' ' + members.lastName) CONTAINS toLower($nameSearch)
      RETURN DISTINCT members LIMIT 5
      """
    )
  bishopMemberCount(id: ID): Int!
    @cypher(
      statement: """
      MATCH (bishop:Member {id: $id})-[:HAS_TOWN|:HAS_CAMPUS]->(campusTown)
      MATCH (campusTown)-[:HAS_CENTRE]->(centre)
      MATCH (centre)-[:HAS_BACENTA]->(bacenta:Bacenta)
      OPTIONAL MATCH (bacenta)<-[:BELONGS_TO*]-(member:Member)
      OPTIONAL MATCH (bacenta)<-[:LEADS]-(bacentaLeader:Member)
      OPTIONAL MATCH (centre)<-[:LEADS]-(centreLeader:Member)
      OPTIONAL MATCH (campusTown)<-[:LEADS]-(constituencyOverseer:Member)
      OPTIONAL MATCH (bishop)<-[:IS_ADMIN_FOR]-(adminBishop:Member)
      OPTIONAL MATCH (campusTown)<-[:IS_ADMIN_FOR]-(adminConstituency:Member)
      UNWIND [member,bacentaLeader,centreLeader,constituencyOverseer,adminBishop,adminConstituency] as members
      WITH members WHERE members IS NOT NULL
      RETURN COUNT(DISTINCT members)
      """
    )
  # campusMemberList(id: ID): [Member]
  #   @cypher(
  #     statement: """
  #     MATCH (campusTown:Campus {id:$id})-[:HAS_CENTRE]->(centre:Centre)-[:HAS_BACENTA]->(bacenta:Bacenta)
  #     OPTIONAL MATCH (bacenta)<-[:BELONGS_TO*]-(member:Member)
  #     OPTIONAL MATCH (bacenta)<-[:LEADS]-(bacentaLeader:Member)
  #     OPTIONAL MATCH (centre)<-[:LEADS]-(centreLeader:Member)
  #     OPTIONAL MATCH (campusTown)<-[:LEADS]-(constituencyOverseer:Member)
  #      OPTIONAL MATCH (campusTown)<-[:IS_ADMIN_FOR]-(adminConstituency:Member)
  #     UNWIND [member,bacentaLeader,centreLeader,constituencyOverseer,adminConstituency] as members
  #     WITH members WHERE members IS NOT NULL
  #     RETURN DISTINCT members
  #     """
  #   )
  # townMemberList(id: ID): [Member]
  #   @cypher(
  #     statement: """
  #     MATCH (campusTown:Town {id:$id})-[:HAS_CENTRE]->(centre:Centre)-[:HAS_BACENTA]->(bacenta:Bacenta)
  #     OPTIONAL MATCH (bacenta)<-[:BELONGS_TO*]-(member:Member)
  #     OPTIONAL MATCH (bacenta)<-[:LEADS]-(bacentaLeader:Member)
  #     OPTIONAL MATCH (centre)<-[:LEADS]-(centreLeader:Member)
  #     OPTIONAL MATCH (campusTown)<-[:LEADS]-(constituencyOverseer:Member)
  #      OPTIONAL MATCH (campusTown)<-[:IS_ADMIN_FOR]-(adminConstituency:Member)
  #     UNWIND [member,bacentaLeader,centreLeader,constituencyOverseer,adminConstituency] as members
  #     WITH members WHERE members IS NOT NULL
  #     RETURN DISTINCT members ORDER BY members.firstName
  #     """
  #   )

  #At the Town Level
  townSontaList(id: ID): [Sonta]
    @cypher(
      statement: "MATCH (town:Town {id: $id})-[:HAS_SONTA]->(sonta:Sonta)  RETURN sonta"
    )
  townCentreCount(id: ID): Int!
    @cypher(
      statement: "MATCH(:Town {id:$id})-[:HAS_CENTRE]->(centre:Centre) RETURN COUNT(centre)"
    )
  townBacentaCount(id: ID): Int!
    @cypher(
      statement: "MATCH (:Town {id:$id})-[]-()-[:HAS_BACENTA]->(bacenta:Bacenta) RETURN COUNT(bacenta)"
    )
  townSontaCount(id: ID): Int!
    @cypher(
      statement: "MATCH (:Town {id:$id})-[:HAS_SONTA]->(sonta:Sonta) RETURN COUNT(sonta)"
    )
  townMemberCount(id: ID): Int!
    @cypher(
      statement: """
      MATCH (campusTown:Town {id:$id})
      OPTIONAL MATCH (campusTown)-[:HAS_CENTRE]->(centre:Centre)-[:HAS_BACENTA]->(bacenta:Bacenta)
      OPTIONAL MATCH (bacenta)<-[:BELONGS_TO*]-(member:Member)
      OPTIONAL MATCH (bacenta)<-[:LEADS]-(bacentaLeader:Member)
      OPTIONAL MATCH (centre)<-[:LEADS]-(centreLeader:Member)
      OPTIONAL MATCH (campusTown)<-[:LEADS]-(constituencyOverseer:Member)
       OPTIONAL MATCH (campusTown)<-[:IS_ADMIN_FOR]-(adminConstituency:Member)
      UNWIND [member,bacentaLeader,centreLeader,constituencyOverseer,adminConstituency] as members
      WITH members WHERE members IS NOT NULL
      RETURN COUNT(DISTINCT members)
      """
    )
  townSontaMemberCount(id: ID): Int!
    @cypher(
      statement: "MATCH (:Town {id: $id})-[]-(:Centre)-[]->(:Bacenta)<-[:BELONGS_TO]-(member:Member) MATCH (member)-[:BELONGS_TO]->(:Ministry) RETURN COUNT(DISTINCT member)"
    )

  #At the Campus Level
  campusBacentaList(id: ID): [Bacenta]
    @cypher(
      statement: "MATCH (campus:Campus {id: $id})-[:HAS_CENTRE]->(:Centre)-[:HAS_BACENTA]-> (bacenta:Bacenta) RETURN bacenta"
    )
  campusSontaList(id: ID): [Sonta]
    @cypher(
      statement: "MATCH (campus:Campus {id: $id})-[:HAS_SONTA]->(sonta:Sonta)  RETURN sonta"
    )
  campusCentreList(id: ID): [Centre]
    @cypher(
      statement: "MATCH (t:Campus {id:$id})-[:HAS_CENTRE]->(centre:Centre) RETURN centre"
    )
  campusCentreCount(id: ID): Int!
    @cypher(
      statement: "MATCH(:Campus {id:$id})-[:HAS_CENTRE]->(centre:Centre) RETURN COUNT(centre)"
    )
  campusBacentaCount(id: ID): Int!
    @cypher(
      statement: "MATCH (:Campus {id:$id})-[]-()-[:HAS_BACENTA]->(bacenta:Bacenta) RETURN COUNT(bacenta)"
    )
  campusSontaCount(id: ID): Int!
    @cypher(
      statement: "MATCH (:Campus {id:$id})-[:HAS_MINISTRY]->(sonta:Sonta) RETURN COUNT(sonta)"
    )
  campusMemberCount(id: ID): Int!
    @cypher(
      statement: """
      MATCH (campusTown:Campus {id:$id})
      OPTIONAL MATCH (campusTown)-[:HAS_CENTRE]->(centre:Centre)-[:HAS_BACENTA]->(bacenta:Bacenta)
      OPTIONAL MATCH (bacenta)<-[:BELONGS_TO*]-(member:Member)
      OPTIONAL MATCH (bacenta)<-[:LEADS]-(bacentaLeader:Member)
      OPTIONAL MATCH (centre)<-[:LEADS]-(centreLeader:Member)
      OPTIONAL MATCH (campusTown)<-[:LEADS]-(constituencyOverseer:Member)
       OPTIONAL MATCH (campusTown)<-[:IS_ADMIN_FOR]-(adminConstituency:Member)
      UNWIND [member,bacentaLeader,centreLeader,constituencyOverseer,adminConstituency] as members
      WITH members WHERE members IS NOT NULL
      RETURN COUNT(DISTINCT members)
      """
    )
  campusSontaMemberCount(id: ID): Int!
    @cypher(
      statement: "MATCH (:Campus {id: $id})-[]-(:Centre)-[]->(:Bacenta)<-[:BELONGS_TO]-(member:Member) MATCH (member)-[:BELONGS_TO]->(:Ministry) RETURN COUNT(DISTINCT member)"
    )

  #At the Centre Level
  centreDropdown(centreName: String): [Centre]
    @cypher(
      statement: "MATCH (centre:Centre) WHERE toLower(centre.name) CONTAINS toLower($centreName) RETURN centre LIMIT 5"
    )
  centreBacentaList(id: ID): [Bacenta]
    @cypher(
      statement: """
      MATCH (bacenta:Bacenta)
      WHERE (:Centre {id:$id})-[:HAS_BACENTA]->(bacenta)
      RETURN bacenta
      """
    )
  centreBacentaCount(id: ID): Int!
    @cypher(
      statement: "MATCH (:Centre {id:$id})-[:HAS_BACENTA]->(bacenta:Bacenta) RETURN COUNT(bacenta)"
    )
  centreSontaCount(id: ID): Int!
    @cypher(
      statement: "MATCH (sonta:Sonta)<-[:HAS_MINISTRY]-(:Centre {name:$centre}) RETURN COUNT(sonta)"
    )
  centreMemberCount(id: ID): Int!
    @cypher(
      statement: """
      MATCH (centre:Centre {id:$id})
      OPTIONAL MATCH (centre)-[:HAS_BACENTA]->(bacenta:Bacenta)
      OPTIONAL MATCH (bacenta)<-[:BELONGS_TO*]-(member:Member)
      OPTIONAL MATCH (bacenta)<-[:LEADS]-(bacentaLeader:Member)
      OPTIONAL MATCH (centre)<-[:LEADS]-(centreLeader:Member)
      UNWIND [member,bacentaLeader,centreLeader] as members
      WITH members WHERE members IS NOT NULL
      RETURN COUNT(DISTINCT members)
      """
    )
  # centreMemberList(id: ID): [Member]
  #   @cypher(
  #     statement: """
  #     MATCH (centre:Centre {id:$id})-[:HAS_BACENTA]->(bacenta:Bacenta)
  #     OPTIONAL MATCH (bacenta)<-[:BELONGS_TO*]-(member:Member)
  #     OPTIONAL MATCH (bacenta)<-[:LEADS]-(bacentaLeader:Member)
  #     OPTIONAL MATCH (centre)<-[:LEADS]-(centreLeader:Member)
  #     UNWIND [member,bacentaLeader,centreLeader] as members
  #     WITH members WHERE members IS NOT NULL
  #     RETURN DISTINCT members ORDER BY members.firstName
  #     """
  #   )

  #At the Bacenta Level
  bacentaMemberCount(id: ID): Int
    @cypher(
      statement: """
      MATCH (bacenta:Bacenta {id:$id})
      OPTIONAL MATCH (bacenta)<-[:BELONGS_TO*]-(member:Member)
      OPTIONAL MATCH (bacenta)<-[:LEADS]-(bacentaLeader:Member)
      UNWIND [member,bacentaLeader] as members
      WITH members WHERE members IS NOT NULL
      RETURN COUNT(DISTINCT members)
      """
    )
  # bacentaMemberList(id: ID): [Member]
  #   @cypher(
  #     statement: """
  #     MATCH (bacenta:Bacenta {id:$id})
  #     OPTIONAL MATCH (bacenta)<-[:BELONGS_TO*]-(member:Member)
  #     OPTIONAL MATCH (bacenta)<-[:LEADS]-(bacentaLeader:Member)
  #     UNWIND [member,bacentaLeader] as members
  #     WITH members WHERE members IS NOT NULL
  #     RETURN DISTINCT members ORDER BY members.firstName
  #     """
  #   )
  bacentaDropdown(bacentaName: String): [Bacenta]
    @cypher(
      statement: "MATCH (bacenta:Bacenta) WHERE toLower(bacenta.name) CONTAINS toLower($bacentaName) RETURN bacenta LIMIT 5"
    )

  #At the Ministry Level
  sontaTownList(bishopId: ID, ministryId: ID): [Town]
    @cypher(
      statement: """
      MATCH (ministry:Ministry {id: $ministryId})<-[:BELONGS_TO]-(member:Member)
      MATCH (member)-[:BELONGS_TO]->(:Bacenta)<-[:HAS_BACENTA]-()<-[:HAS_CENTRE]-(campusTown)
      MATCH (campusTown)<-[:HAS_TOWN|HAS_CAMPUS]-(:Member {id: $bishopId})
      RETURN DISTINCT campusTown,ministry
      """
    )

  #At the Sonta Level
  sontaList: [Sonta] @cypher(statement: "MATCH (s:Sonta) RETURN s")
  townSontaLeader(bishopId: ID): [Member]
    @cypher(
      statement: """
      MATCH (ministry:Ministry)<-[:BELONGS_TO]-(member:Member)
      MATCH (member)-[:BELONGS_TO]->(:Bacenta)<-[:HAS_BACENTA]-()<-[:HAS_CENTRE]-(campusTown)
      MATCH (campusTown)<-[:HAS_TOWN|HAS_CAMPUS]-(:Member {id: $bishopId})
      MATCH (campusTown)-[:HAS_SONTA]->(s:Sonta {id:$sontaId})<-[:LEADS]-(sontaLeader:Member)
      WHERE sonta.name CONTAINS campusTown.name
         RETURN DISTINCT sontaLeader
      """
    )
  # sontaMemberList(id: ID): [Member]
  #   @cypher(
  #     statement: """
  #     MATCH (sonta:Sonta {id: $id})
  #     MATCH (sonta)<-[:HAS_SONTA]-()-[:HAS_CENTRE]->()-[:HAS_BACENTA]->()<-[:BELONGS_TO]-(member:Member)
  #     RETURN member
  #     """
  #   )
  sontaMemberCount(id: ID): Int!
    @cypher(
      statement: """
      MATCH (sonta:Sonta {id: $id})
      MATCH (sonta)<-[:HAS_SONTA]-()-[:HAS_CENTRE]->()-[:HAS_BACENTA]->()<-[:BELONGS_TO]-(member:Member)
      MATCH (sonta)<-[:HAS_SONTA]-(ministry:Ministry)
      MATCH (member)-[:BELONGS_TO]->(ministry)
      RETURN COUNT(member)
      """
    )
  sontaBasontaLeaderList(id: ID): [Member]
    @cypher(
      statement: """
      MATCH (sonta:Sonta {id: $id})
      MATCH (basonta:Basonta)<-[:HAS_BASONTA]-(sonta)
      MATCH (basonta)<-[:LEADS]-(leader)
      RETURN leader
      """
    )

  #Members
  # Display Member based on ID
  currentUser(id: ID): Member
    @cypher(
      statement: "MATCH (member:Member {auth_id: $auth.jwt.sub}) RETURN member"
    )
    @auth(rules: [{ isAuthenticated: true }])

  member(id: ID): Member
    @cypher(statement: "MATCH (member:Member {id:$id}) RETURN member LIMIT 1")

  #Fuzzy Search
  memberGridList(
    gender: String
    maritalStatus: String
    ministryId: ID
    leaderTitle: String
    leaderRank: String
  ): [Member]
    @cypher(
      statement: """
      MATCH (member:Member)
      WHERE (member)-[:HAS_GENDER]->(:Gender{gender:$gender})
      OR (member)-[:HAS_MARITAL_STATUS]->(:MaritalStatus{status:$maritalStatus})
      RETURN member
      """
    )

  federalMemberSearch(searchKey: String): [Member]
    @auth(rules: [{ roles: ["adminFederal"] }])
    @cypher(
      statement: """
      MATCH (member:Member)
      WHERE toLower(member.firstName) = toLower($searchKey)
      OR toLower(member.middleName) = toLower($searchKey)
      OR toLower(member.lastName) = toLower($searchKey)
      OR toLower(member.firstName) STARTS WITH toLower($searchKey)
      OR toLower(member.middleName) STARTS WITH toLower($searchKey)
      OR toLower(member.lastName) STARTS WITH toLower($searchKey)
      OR toLower(member.firstName + ' ' + member.middleName+ ' '+ member.lastName) CONTAINS toLower($searchKey)
      RETURN member LIMIT 5
      """
    )
  bishopMemberSearch(searchKey: String, bishopId: ID): [Member]
    @auth(rules: [{ roles: ["adminBishop"] }])
    @cypher(
      statement: """
      MATCH (bishop:Member {id: $bishopId})-[:HAS_TOWN|:HAS_CAMPUS]->(campusTown)
      MATCH (campusTown)-[:HAS_CENTRE]->(centre)
      MATCH (centre)-[:HAS_BACENTA]->(bacenta:Bacenta)
      OPTIONAL MATCH (bacenta)<-[:BELONGS_TO*]-(member:Member)
      OPTIONAL MATCH (bacenta)<-[:LEADS]-(bacentaLeader:Member)
      OPTIONAL MATCH (centre)<-[:LEADS]-(centreLeader:Member)
      OPTIONAL MATCH (campusTown)<-[:LEADS]-(constituencyOverseer:Member)
      OPTIONAL MATCH (bishop)<-[:IS_ADMIN_FOR]-(adminBishop:Member)
      OPTIONAL MATCH (campusTown)<-[:IS_ADMIN_FOR]-(adminConstituency:Member)
      UNWIND [member,bacentaLeader,centreLeader,constituencyOverseer,adminBishop,adminConstituency] as members
      WITH members WHERE members IS NOT NULL

      AND toLower(members.firstName) = toLower($searchKey)
      OR toLower(members.lastName) = toLower($searchKey)
      OR toLower(members.firstName) STARTS WITH toLower($searchKey)
      OR toLower(members.lastName) STARTS WITH toLower($searchKey)
      OR toLower(member.firstName + ' ' + member.middleName+ ' '+ member.lastName) CONTAINS toLower($searchKey)
      RETURN DISTINCT(members) LIMIT 5
      """
    )
  constituencyMemberSearch(searchKey: String, constituencyId: ID): [Member]
    @auth(rules: [{ roles: ["adminCampus", "adminTown"] }])
    @cypher(
      statement: """
      MATCH (constituency {id:$constituencyId}) WHERE constituency:Campus OR constituency:Town
      MATCH (constituency)-[:HAS_CENTRE]->(centre)
      MATCH (centre)-[:HAS_BACENTA]->(bacenta:Bacenta)
      OPTIONAL MATCH (bacenta)<-[:BELONGS_TO*]-(member:Member)
      OPTIONAL MATCH (bacenta)<-[:LEADS]-(bacentaLeader:Member)
      OPTIONAL MATCH (centre)<-[:LEADS]-(centreLeader:Member)
      OPTIONAL MATCH (constituency)<-[:LEADS]-(constituencyOverseer:Member)
      OPTIONAL MATCH (constituency)<-[:IS_ADMIN_FOR]-(adminConstituency:Member)
      UNWIND [member,bacentaLeader,centreLeader,constituencyOverseer,adminConstituency] as members
      WITH members WHERE members IS NOT NULL

      AND toLower(members.firstName) = toLower($searchKey)
      OR toLower(members.lastName) = toLower($searchKey)
      OR toLower(members.firstName) STARTS WITH toLower($searchKey)
      OR toLower(members.lastName) STARTS WITH toLower($searchKey)
      OR toLower(member.firstName + ' ' + member.middleName+ ' '+ member.lastName) CONTAINS toLower($searchKey)
      RETURN DISTINCT(members) LIMIT 5
      """
    )
  federalBacentaSearch(searchKey: String): [Bacenta]
    @auth(rules: [{ roles: ["adminFederal"] }])
    @cypher(
      statement: """
      MATCH (bacenta:Bacenta)
      WHERE toLower(bacenta.name) STARTS WITH toLower($searchKey)
      OR toLower(bacenta.name) CONTAINS toLower($searchKey)
      RETURN bacenta LIMIT 5
      """
    )
  bishopBacentaSearch(searchKey: String, bishopId: ID): [Bacenta]
    @auth(rules: [{ roles: ["adminBishop"] }])
    @cypher(
      statement: """
      MATCH (bishop:Member {id: $bishopId})-[:HAS_TOWN|:HAS_CAMPUS]->(campusTown)
      MATCH (campusTown)-[:HAS_CENTRE]->(centre)
      MATCH (centre)-[:HAS_BACENTA]->(bacenta:Bacenta)

      WHERE toLower(bacenta.name) STARTS WITH toLower($searchKey)
      OR toLower(bacenta.name) CONTAINS toLower($searchKey)
      RETURN bacenta LIMIT 5
      """
    )
  constituencyBacentaSearch(searchKey: String, constituencyId: ID): [Bacenta]
    @auth(rules: [{ roles: ["adminCampus", "adminTown"] }])
    @cypher(
      statement: """
      MATCH (constituency {id:$constituencyId}) WHERE constituency:Campus OR constituency:Town
      MATCH (constituency)-[:HAS_CENTRE]->(centre)
      MATCH (centre)-[:HAS_BACENTA]->(bacenta:Bacenta)

      WHERE toLower(bacenta.name) STARTS WITH toLower($searchKey)
      OR toLower(bacenta.name) CONTAINS toLower($searchKey)
      RETURN bacenta LIMIT 5
      """
    )
  federalCentreSearch(searchKey: String): [Centre]
    @auth(rules: [{ roles: ["adminFederal"] }])
    @cypher(
      statement: """
      MATCH (centre:Centre)
      WHERE toLower(centre.name) STARTS WITH toLower($searchKey)
      OR toLower(centre.name) CONTAINS toLower($searchKey)
      RETURN centre LIMIT 5
      """
    )
  bishopCentreSearch(searchKey: String, bishopId: ID): [Centre]
    @auth(rules: [{ roles: ["adminBishop"] }])
    @cypher(
      statement: """
      MATCH (bishop:Member {id: $bishopId})-[:HAS_TOWN|:HAS_CAMPUS]->(campusTown)
      MATCH (campusTown)-[:HAS_CENTRE]->(centre)

      WHERE toLower(centre.name) STARTS WITH toLower($searchKey)
      OR toLower(centre.name) CONTAINS toLower($searchKey)
      RETURN centre LIMIT 5
      """
    )
  constituencyCentreSearch(searchKey: String, constituencyId: ID): [Bacenta]
    @auth(rules: [{ roles: ["adminCampus", "adminTown"] }])
    @cypher(
      statement: """
      MATCH (constituency {id:$constituencyId}) WHERE constituency:Campus OR constituency:Town
      MATCH (constituency)-[:HAS_CENTRE]->(centre)

      WHERE toLower(centre.name) STARTS WITH toLower($searchKey)
      OR toLower(centre.name) CONTAINS toLower($searchKey)
      RETURN centre LIMIT 5
      """
    )
  federalCampusSearch(searchKey: String): [Campus]
    @auth(rules: [{ roles: ["adminFederal"] }])
    @cypher(
      statement: """
      MATCH (campus:Campus)
      WHERE toLower(campus.name) STARTS WITH toLower($searchKey)
      OR toLower(campus.name) CONTAINS toLower($searchKey)
      RETURN campus LIMIT 5
      """
    )
  bishopCampusSearch(searchKey: String, bishopId: ID): [Campus]
    @auth(rules: [{ roles: ["adminBishop"] }])
    @cypher(
      statement: """
      MATCH (bishop:Member {id: $bishopId})-[:HAS_TOWN|:HAS_CAMPUS]->(campus)

      WHERE toLower(campus.name) STARTS WITH toLower($searchKey)
      OR toLower(campus.name) CONTAINS toLower($searchKey)
      RETURN campus LIMIT 5
      """
    )
  federalTownSearch(searchKey: String): [Town]
    @auth(rules: [{ roles: ["adminFederal"] }])
    @cypher(
      statement: """
      MATCH (town:Town)
      WHERE toLower(town.name) STARTS WITH toLower($searchKey)
      OR toLower(town.name) CONTAINS toLower($searchKey)
      RETURN town LIMIT 5
      """
    )
  bishopTownSearch(searchKey: String, bishopId: ID): [Town]
    @auth(rules: [{ roles: ["adminBishop"] }])
    @cypher(
      statement: """
      MATCH (bishop:Member {id: $bishopId})-[:HAS_TOWN|:HAS_CAMPUS]->(town)

      WHERE toLower(town.name) STARTS WITH toLower($searchKey)
      OR toLower(town.name) CONTAINS toLower($searchKey)
      RETURN town LIMIT 5
      """
    )
  federalSontaSearch(searchKey: String): [Sonta]
    @auth(rules: [{ roles: ["adminFederal"] }])
    @cypher(
      statement: """
      MATCH (sonta:Sonta)
      WHERE toLower(sonta.name) STARTS WITH toLower($searchKey)
      OR toLower(sonta.name) CONTAINS toLower($searchKey)
      RETURN sonta LIMIT 5
      """
    )
  bishopSontaSearch(searchKey: String, bishopId: ID): [Sonta]
    @auth(rules: [{ roles: ["adminBishop"] }])
    @cypher(
      statement: """
      MATCH (bishop:Member {id: $bishopId})-[:HAS_TOWN|:HAS_CAMPUS]->(campusTown)
      MATCH (campusTown)-[:HAS_SONTA]->(sonta)

      WHERE toLower(sonta.name) STARTS WITH toLower($searchKey)
      OR toLower(sonta.name) CONTAINS toLower($searchKey)
      RETURN sonta LIMIT 5
      """
    )
  constituencySontaSearch(searchKey: String, constituencyId: ID): [Bacenta]
    @auth(rules: [{ roles: ["adminCampus", "adminTown"] }])
    @cypher(
      statement: """
      MATCH (constituency {id:$constituencyId}) WHERE constituency:Campus OR constituency:Town
      MATCH (constituency)-[:HAS_SONTA]->(sonta)

      WHERE toLower(sonta.name) STARTS WITH toLower($searchKey)
      OR toLower(sonta.name) CONTAINS toLower($searchKey)
      RETURN sonta LIMIT 5
      """
    )

  occupationList(searchKey: String!): [Occupation]
    @cypher(
      statement: "MATCH (occupation:Occupation) WHERE toLower(occupation.occupation) CONTAINS toLower($searchKey) RETURN occupation"
    )
}

#Mutation Definitions
type Mutation {
  #resolver Mutations
  MakeBishopAdmin(adminId: ID!, bishopId: ID!): Member
  RemoveBishopAdmin(adminId: ID!, bishopId: ID!): Member
  MakeTownAdmin(adminId: ID!, townId: ID!): Member
  RemoveTownAdmin(adminId: ID!, townId: ID!): Member
  MakeCampusAdmin(adminId: ID!, campusId: ID!): Member
  RemoveCampusAdmin(adminId: ID!, campusId: ID!): Member
  MakeBacentaLeader(leaderId: ID!, bacentaId: ID!): Member
  RemoveBacentaLeader(leaderId: ID!, bacentaId: ID!): Member
  MakeCentreLeader(leaderId: ID!, centreId: ID!): Member
  RemoveCentreLeader(leaderId: ID!, centreId: ID!): Member
  MakeSontaLeader(leaderId: ID!, sontaId: ID!): Member
  RemoveSontaLeader(leaderId: ID!, sontaId: ID!): Member
  MakeTownLeader(leaderId: ID!, townId: ID!): Member
  RemoveTownLeader(leaderId: ID!, townId: ID!): Member
  MakeCampusLeader(leaderId: ID!, campusId: ID!): Member
  RemoveCampusLeader(leaderId: ID!, campusId: ID!): Member

  #CREATE OPERATIONS
  # Add Member to the Database
  CreateMember(
    firstName: String!
    middleName: String
    lastName: String!
    email: String!
    phoneNumber: String!
    whatsappNumber: String
    dob: String!
    maritalStatus: String!
    gender: String!
    occupation: String
    bacenta: String!
    ministry: String
    pictureUrl: String!
  ): Member
    @auth(
      rules: [
        {
          roles: [
            "adminFederal"
            "adminBishop"
            "adminCampus"
            "adminTown"
            "leaderBacenta"
            "leaderCentre"
            "leaderCampus"
            "leaderTown"
          ]
        }
      ]
    )
    @cypher(
      statement: """
      CREATE (member:Member {whatsappNumber:$whatsappNumber})
      SET
      	member.id = apoc.create.uuid(),
      	member.firstName = $firstName,
      	member.middleName = $middleName,
      	member.lastName = $lastName,
      	member.email = $email,
      	member.phoneNumber = $phoneNumber,
      	member.pictureUrl = $pictureUrl
      CREATE (log:HistoryLog)<-[:HAS_HISTORY]-(b)
        SET
        log.id =  apoc.create.uuid(),
        log.timeStamp = datetime(),
        log.historyRecord = $firstName +' ' +$lastName+' was registered on '+apoc.date.convertFormat(toString(date()), 'date', 'dd MMMM yyyy')



      WITH member, log
      MATCH (currentUser:Member {auth_id:$auth.jwt.sub})
      MERGE (date:TimeGraph {date: date()})
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (log)-[:LOGGED_BY]->(currentUser)
      MERGE (member)-[:HAS_HISTORY]->(log)

      WITH member
      MATCH (maritalStatus:MaritalStatus {status:$maritalStatus})
      MATCH (gender:Gender {gender: $gender})

      MERGE (member)-[:HAS_MARITAL_STATUS]-> (maritalStatus)
      MERGE (member)-[:HAS_GENDER]-> (gender)

      WITH member
         CALL {
         	WITH member
         	WITH member WHERE $dob IS NOT NULL
         	MERGE (date:TimeGraph {date: date($dob)})
      	  MERGE (member)-[:WAS_BORN_ON]->(date)
         	RETURN count(member)
         	}

      WITH member
         CALL {
         	WITH member
         	WITH member  WHERE $occupation IS NOT NULL
         	MERGE (occupation:Occupation {occupation:$occupation})
      	MERGE (member)-[:HAS_OCCUPATION]-> (occupation)
         	RETURN count(member)
         	}
      WITH member
      CALL {
         	WITH member
         	WITH member  WHERE $bacenta IS NOT NULL
         	MATCH (bacenta:Bacenta {id: $bacenta})
      	  MERGE (member)-[:BELONGS_TO]->(bacenta)
         	RETURN count(member)
         	}

      WITH member
      CALL {
         	WITH member
         	WITH member  WHERE $ministry IS NOT NULL
         	MATCH (ministry:Ministry {id:$ministry})
      	MERGE (member)-[:BELONGS_TO]-> (ministry)
         	RETURN count(member)
         	}

      RETURN member
      """
    )

  CreateTown(
    townName: String!
    leaderId: ID!
    bishopId: ID!
    centres: [ID]
  ): Town
    @auth(rules: [{ roles: ["adminFederal", "adminBishop"] }])
    @cypher(
      statement: """
       CREATE (town:Town {name:$townName})
         	SET
      	town.id = apoc.create.uuid()
      WITH town
      MATCH (leader:Member {id: $leaderId})
      MATCH (currentUser:Member {auth_id:$auth.jwt.sub})
      MATCH (bishop:Member {id: $bishopId})

       CREATE (log:HistoryLog)
        SET
        log.id =  apoc.create.uuid(),
        log.timeStamp = datetime(),
        log.historyRecord = leader.firstName + ' ' +leader.lastName + ' started ' + $townName +' Town Church under Bishop '+ bishop.firstName+ ' ' + bishop.lastName

      MERGE (bishop)-[:HAS_TOWN]->(town)
      MERGE (leader)-[:LEADS]->(town)

      MERGE (date:TimeGraph {date: date(date())})
      MERGE (log)-[:LOGGED_BY]->(currentUser)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (bishop)-[:HAS_HISTORY]->(log)
      MERGE (town)-[:HAS_HISTORY]->(log)
      MERGE (leader)-[r:HAS_HISTORY]->(log)
        SET r.current = true

      WITH town, bishop
      CALL {
        WITH town
        WITH town WHERE $centres <> []
        UNWIND $centres AS centreIds
        MATCH (centre:Centre {id:centreIds})
        OPTIONAL MATCH (oldCampusTown)-[r:HAS_CENTRE]->(centre)
        DELETE r

        MERGE (town)-[:HAS_CENTRE]->(centre)
        RETURN count(town)
      }

      RETURN town
      """
    )
  CreateCampus(
    campusName: String!
    leaderId: ID!
    bishopId: ID!
    centres: [ID]
  ): Campus
    @auth(rules: [{ roles: ["adminFederal", "adminBishop"] }])
    @cypher(
      statement: """
      CREATE (campus:Campus {name:$campusName})
         	SET
      	campus.id = apoc.create.uuid()
      WITH campus
      MATCH (leader:Member {id: $leaderId})
      MATCH (currentUser:Member {auth_id:$auth.jwt.sub})
      MATCH (bishop:Member {id: $bishopId})

       CREATE (log:HistoryLog)
        SET
        log.id =  apoc.create.uuid(),
        log.timeStamp = datetime(),
        log.historyRecord = leader.firstName + ' ' +leader.lastName + ' started ' + $campusName +' Campus Church under Bishop '+ bishop.firstName+ ' ' + bishop.lastName

      MERGE (bishop)-[:HAS_CAMPUS]->(campus)
      MERGE (leader)-[:LEADS]->(campus)

      MERGE (date:TimeGraph {date: date(date())})
      MERGE (log)-[:LOGGED_BY]->(currentUser)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (bishop)-[:HAS_HISTORY]->(log)
      MERGE (campus)-[:HAS_HISTORY]->(log)
      MERGE (leader)-[r:HAS_HISTORY]->(log)
        SET r.current = true

      WITH campus, bishop
      CALL {
        WITH campus
        WITH campus WHERE $centres <> []
        UNWIND $centres AS centreIds
        MATCH (centre:Centre {id:centreIds})
        OPTIONAL MATCH (oldCampusTown)-[r:HAS_CENTRE]->(centre)
        DELETE r

        MERGE (campus)-[:HAS_CENTRE]->(centre)
        RETURN count(campus)
      }

      RETURN campus
      """
    )

  CreateCentre(
    centreName: String!
    townCampusId: ID!
    leaderId: ID!
    bacentas: [ID]
  ): Centre  #Return town and drill down to get centre info
    @auth(
      rules: [
        { roles: ["adminFederal", "adminBishop", "adminCampus", "adminTown"] }
      ]
    )
    @cypher(
      statement: """
      CREATE (centre:Centre {name:$centreName})
         	SET
      	centre.id = apoc.create.uuid()
      WITH centre
       MATCH (leader:Member {id:$leaderId})
       MATCH (campusTown {id:$townCampusId}) WHERE campusTown:Town OR campusTown:Campus
       MATCH (currentUser:Member {auth_id:$auth.jwt.sub})
       UNWIND labels(campusTown) AS stream

      CREATE (log:HistoryLog:ServiceLog)
      SET log.id = apoc.create.uuid(),
       log.timeStamp = datetime(),
       log.historyRecord = leader.firstName + ' ' +leader.lastName + ' started ' + centre.name +' Centre under '+ campusTown.name + ' ' + stream

       MERGE (campusTown)-[:HAS_CENTRE]->(centre)
       MERGE (leader)-[:LEADS]->(centre)

       MERGE (date:TimeGraph {date: date(date())})
       MERGE (log)-[:LOGGED_BY]->(currentUser)
       MERGE (log)-[:RECORDED_ON]->(date)
       MERGE (campusTown)-[:HAS_HISTORY]->(log)
       MERGE (centre)-[:HAS_HISTORY]->(log)
       MERGE (leader)-[r:HAS_HISTORY]->(log)
        SET r.current = true

       WITH centre
      CALL {
        WITH centre
        WITH centre WHERE $bacentas <> []
        UNWIND $bacentas AS bacentaIds
        MATCH (bacenta:Bacenta {id:bacentaIds})
        OPTIONAL MATCH (oldCentre)-[r:HAS_BACENTA]->(bacenta)
        DELETE r

        MERGE (centre)-[:HAS_BACENTA]->(bacenta)
        RETURN count(centre)
      }

      RETURN centre
      """
    )
  CreateSonta(ministryId: ID!, townCampusId: ID!, leaderId: ID!): Town
    @auth(
      rules: [
        { roles: ["adminFederal", "adminBishop", "adminCampus", "adminTown"] }
      ]
    )
    @cypher(
      statement: """
      CREATE (sonta:Sonta)
         	SET
      	sonta.id = apoc.create.uuid()
      WITH sonta
       MATCH (ministry:Ministry {id:$ministryId})
       MATCH (leader:Member {id: $leaderId})
       MATCH (campusTown {id:$townCampusId}) WHERE campusTown:Town OR campusTown:Campus

       MATCH (currentUser:Member {auth_id:$auth.jwt.sub})
       UNWIND labels(campusTown) AS stream

       CREATE (log:HistoryLog:ServiceLog)
        SET log.id = apoc.create.uuid(),
         log.timeStamp = datetime(),
         log.historyRecord = leader.firstName + ' ' +leader.lastName + ' started ' + sonta.name +' Sonta under '+ campusTown.name + ' ' + stream


       SET sonta.name = campusTown.name + ' ' + ministry.name
       MERGE (date:TimeGraph {date: date(date())})
       MERGE (ministry)-[:HAS_SONTA]->(sonta)
       MERGE (campusTown)-[:HAS_SONTA]->(sonta)
       MERGE (leader)-[:LEADS]->(sonta)

      MERGE (date:TimeGraph {date: date(date())})
      MERGE (log)-[:LOGGED_BY]->(currentUser)
       MERGE (log)-[:RECORDED_ON]->(date)
       MERGE (campusTown)-[:HAS_HISTORY]->(log)
       MERGE (sonta)-[:HAS_HISTORY]->(log)
       MERGE (leader)-[r:HAS_HISTORY]->(log)
        SET r.current = true

      RETURN campusTown
      """
    )
  CreateBacenta(
    bacentaName: String!
    centreId: ID!
    leaderId: ID!
    meetingDay: String!
    venueLongitude: Float
    venueLatitude: Float
  ): Bacenta
    @auth(
      rules: [
        { roles: ["adminFederal", "adminBishop", "adminCampus", "adminTown"] }
      ]
    )
    @cypher(
      statement: """
      CREATE (bacenta:Bacenta {name:$bacentaName,location: point({latitude:toFloat($venueLatitude), longitude:toFloat($venueLongitude), crs:'WGS-84'})})
         	SET
      	bacenta.id = apoc.create.uuid()

      WITH bacenta
      MATCH (centre:Centre {id: $centreId})
      MATCH (leader:Member {id:$leaderId})
      MATCH (currentUser:Member {auth_id:$auth.jwt.sub})
      MATCH (meetingDay:ServiceDay {day: $meetingDay})

      CREATE (log:HistoryLog:ServiceLog)
      SET log.id = apoc.create.uuid(),
       log.timeStamp = datetime(),
       log.historyRecord = leader.firstName + ' ' +leader.lastName + ' started ' + bacenta.name+' Bacenta under '+ centre.name + ' Centre'

      MERGE (centre)-[:HAS_BACENTA]->(bacenta)
      MERGE (leader)-[:LEADS]->(bacenta)
      MERGE (bacenta)-[:MEETS_ON]->(meetingDay)

      MERGE (date:TimeGraph {date: date(date())})
      MERGE (log)-[:LOGGED_BY]->(currentUser)
       MERGE (log)-[:RECORDED_ON]->(date)
       MERGE (centre)-[:HAS_HISTORY]->(log)
       MERGE (bacenta)-[:HAS_HISTORY]->(log)
       MERGE (leader)-[r:HAS_HISTORY]->(log)
        SET r.current = true

      RETURN bacenta
      """
    )

  #UPDATE OPERATIONS
  UpdateMemberDetails(
    id: ID!
    firstName: String!
    middleName: String
    lastName: String!
    email: String
    phoneNumber: String!
    whatsappNumber: String
    dob: String
    maritalStatus: String!
    gender: String!
    occupation: String
    bacenta: String
    ministry: String
    pictureUrl: String!
  ): Member
    @auth(
      rules: [
        {
          roles: [
            "adminFederal"
            "adminBishop"
            "adminCampus"
            "adminTown"
            "leaderBacenta"
            "leaderCentre"
            "leaderCampus"
            "leaderTown"
          ]
        }
      ]
    )
    @cypher(
      statement: """
      MATCH (member:Member {id:$id})
      SET
      	member.firstName = $firstName,
      	member.middleName = $middleName,
      	member.lastName = $lastName,
      	member.email = $email,
      	member.phoneNumber = $phoneNumber,
        member.whatsappNumber = $whatsappNumber,
      	member.pictureUrl = $pictureUrl

      WITH member

      MATCH (gender:Gender {gender: $gender})
      MERGE (member)-[:HAS_GENDER]-> (gender)


      WITH member
         CALL {
         	WITH member
         	WITH member  WHERE $dob IS NOT NULL
         	MERGE (date:TimeGraph {date: date($dob)})
      	WITH member,date
      	OPTIONAL MATCH (member)-[r1:WAS_BORN_ON]->()
      	DELETE r1
      	MERGE (member)-[:WAS_BORN_ON]->(date)
         	RETURN count(member)
         	}

      WITH member
         CALL {
         	WITH member
         	WITH member  WHERE $maritalStatus IS NOT NULL
         	MATCH (maritalStatus:MaritalStatus {status:$maritalStatus})
      	OPTIONAL MATCH (member)-[r1:HAS_MARITAL_STATUS]->()
      	DELETE r1
      	MERGE (member)-[:HAS_MARITAL_STATUS]-> (maritalStatus)
         	RETURN count(member)
         	}

         WITH member
         CALL {
         	WITH member
         	WITH member  WHERE $occupation IS NOT NULL
      	OPTIONAL MATCH (member)-[r1:HAS_OCCUPATION]-> ()
        MERGE (occupation:Occupation {occupation:$occupation})
      	DELETE r1
      	MERGE (member)-[:HAS_OCCUPATION]-> (occupation)
         	RETURN count(member)
         	}
      WITH member
      CALL {
         	WITH member
         	WITH member  WHERE $bacenta IS NOT NULL
         	MATCH (bacenta:Bacenta {id: $bacenta})
      	OPTIONAL MATCH (member)-[r0:BELONGS_TO]-> (:Bacenta)
      	DELETE r0
      	MERGE (member)-[:BELONGS_TO]-> (bacenta)
         	RETURN count(member)
         	}
      WITH member
      CALL {
         	WITH member
         	WITH member  WHERE $ministry IS NOT NULL
         	MATCH (ministry:Ministry {id:$ministry})
      	OPTIONAL MATCH (member)-[r0:BELONGS_TO]-> (:Ministry)
      	DELETE r0
      	MERGE (member)-[:BELONGS_TO]-> (ministry)
         	RETURN count(member)
         	}

      RETURN member
      """
    )

  UpdateTownDetails(townId: ID!, townName: String!, bishopId: ID!): Town
    @auth(rules: [{ roles: ["adminFederal", "adminBishop"] }])
    @cypher(
      statement: """
      MATCH (town:Town {id: $townId})
      	SET town.name = $townName

      WITH town
         CALL {
         	WITH town
          MATCH (bishop:Member {id: $bishopId})
          OPTIONAL MATCH (town)<-[r:HAS_TOWN]-()
          DELETE r
          MERGE (bishop)-[:HAS_TOWN]->(town)
         	RETURN count(town)
         	}

      MATCH (town)<-[:LEADS]-(leader:Member)
      RETURN town
      """
    )
  UpdateCampusDetails(
    campusId: ID!
    campusName: String!
    bishopId: ID!
  ): Campus
    @auth(rules: [{ roles: ["adminFederal", "adminBishop"] }])
    @cypher(
      statement: """
           MATCH (campus:Campus {id: $campusId})
           	SET campus.name = $campusName

           WITH campus
              CALL {
              	WITH campus

                  MATCH (bishop:Member {id: $bishopId})
                  OPTIONAL MATCH (campus)<-[r:HAS_CAMPUS]-()
                  DELETE r
                  MERGE (bishop)-[:HAS_CAMPUS]->(campus)
              	RETURN count(campus)
              	}
      MATCH (campus)<-[:LEADS]-(leader:Member)
      RETURN campus
      """
    )
  UpdateCentreDetails(
    centreId: ID!
    centreName: String!
    campusTownId: ID!
  ): Centre
    @auth(
      rules: [
        { roles: ["adminFederal", "adminBishop", "adminCampus", "adminTown"] }
      ]
    )
    @cypher(
      statement: """
      MATCH (centre:Centre {id: $centreId})
      	SET centre.name = $centreName

      WITH centre
         CALL {
         	WITH centre
      		OPTIONAL MATCH (campusTown {id: $campusTownId}) WHERE campusTown:Campus OR campusTown:Town

            OPTIONAL MATCH (centre)<-[r:HAS_CENTRE]-()
            DELETE r
            MERGE (campusTown)-[:HAS_CENTRE]->(centre)
         	RETURN count(centre)
         	}
      MATCH (centre)<-[:LEADS]-(leader:Member)
      RETURN centre
      """
    )

  UpdateSontaDetails(sontaId: ID!, sontaName: String!): Sonta
    @auth(
      rules: [
        { roles: ["adminFederal", "adminBishop", "adminCampus", "adminTown"] }
      ]
    )
    @cypher(
      statement: """
      MATCH (sonta:Sonta {id: $sontaId})
      	SET sonta.name = $sontaName

      WITH sonta
      MATCH (sonta)<-[:LEADS]-(leader:Member)
      RETURN sonta
      """
    )

  UpdateBacentaDetails(
    id: ID!
    name: String!
    meetingDay: String
    venueLongitude: Float
    venueLatitude: Float
  ): Bacenta
    @auth(
      rules: [
        { roles: ["adminFederal", "adminBishop", "adminCampus", "adminTown"] }
      ]
    )
    @cypher(
      statement: """
               MATCH (bacenta:Bacenta {id: $id})
               	SET bacenta.name = $name
              	SET bacenta.location = point({latitude:toFloat($venueLatitude), longitude:toFloat($venueLongitude), crs:'WGS-84'})

               WITH bacenta
                    CALL {
                     	WITH bacenta
                      WITH bacenta WHERE $meetingDay IS NOT NULL
                      MATCH (meetingDay:ServiceDay {day: $meetingDay})
                      OPTIONAL MATCH (bacenta)-[r:MEETS_ON]->()
                      DELETE r
                      MERGE (bacenta)-[:MEETS_ON]->(meetingDay)
                     	RETURN count(bacenta)
                     	}
      MATCH (bacenta)-[:LEADS]-(leader:Member)
      RETURN bacenta
      """
    )
  #DIFFERENT LOG HISTORY MUTATIONS
  LogBacentaHistory(
    bacentaId: ID!
    historyRecord: String!
    oldLeaderId: ID
    newLeaderId: ID
    oldCentreId: ID
    newCentreId: ID
  ): Bacenta
    @cypher(
      statement: """
      MATCH  (bacenta:Bacenta {id: $bacentaId})
      MATCH (admin:Member {auth_id: $auth.jwt.sub})
      CREATE (log:HistoryLog {id: apoc.create.uuid()})
        SET log.historyRecord = $historyRecord,
          log.timeStamp = datetime()
      MERGE (date:TimeGraph {date: date()})
      MERGE (bacenta)-[r:HAS_HISTORY]->(log)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (log)-[:LOGGED_BY]->(admin)


      WITH log,bacenta
      CALL{
        WITH log
        WITH log WHERE $oldCentreId IS NOT NULL
        MATCH (oldCentre:Centre {id: $oldCentreId})
        MERGE (oldCentre)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      WITH log,bacenta
      CALL{
        WITH log
        WITH log WHERE $newCentreId IS NOT NULL
        MATCH (newCentre:Centre {id: $newCentreId})
        MERGE (newCentre)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      RETURN bacenta
      """
    )
  LogCentreHistory(
    centreId: ID!
    historyRecord: String!
    newLeaderId: ID
    oldLeaderId: ID
    newCampusTownId: ID
    oldCampusTownId: ID
  ): Centre
    @cypher(
      statement: """
       MATCH  (centre:Centre {id: $centreId})
       MATCH (admin:Member {auth_id: $auth.jwt.sub})
       CREATE (log:HistoryLog {id: apoc.create.uuid()})
         SET log.historyRecord = $historyRecord,
           log.timeStamp = datetime()
       MERGE (date:TimeGraph {date: date()})
       MERGE (centre)-[r:HAS_HISTORY]->(log)
       MERGE (log)-[:RECORDED_ON]->(date)
        MERGE (log)-[:LOGGED_BY]->(admin)

       WITH log,centre
       CALL{
         WITH log
         WITH log WHERE $newLeaderId IS NOT NULL
       MATCH (newLeader:Member {id: $newLeaderId})
      OPTIONAL MATCH (oldLeader:Member {id: $oldLeaderId})
         SET log :ServiceLog
         WITH log, newLeader,oldLeader
       OPTIONAl MATCH (log)<-[r0:HAS_HISTORY]-()
         SET r0.current = false
         WITH log,newLeader,oldLeader
       CREATE (oldLeader)-[:HAS_HISTORY]->(log)
       CREATE (newLeader)-[r:HAS_HISTORY]->(log)
          SET r.current = true
          WITH log
       RETURN COUNT(log)
       }


       WITH log,centre
       CALL {
         WITH log
         WITH log WHERE $oldCampusTownId IS NOT NULL
         MATCH (oldCampusTown {id: $oldCampusTownId}) WHERE oldCampusTown:Town OR oldCampusTown:Campus
         MERGE (oldCampusTown)-[:HAS_HISTORY]->(log)
         RETURN COUNT(log)
       }

       WITH log,centre
       CALL {
         WITH log
         WITH log WHERE $newCampusTownId IS NOT NULL
         MATCH (newCampusTown {id: $newCampusTownId}) WHERE newCampusTown:Town OR newCampusTown:Campus
         MERGE (newCampusTown)-[:HAS_HISTORY]->(log)
         RETURN COUNT(log)
       }

       RETURN centre
      """
    )
  LogCampusTownHistory(
    campusTownId: ID!
    historyRecord: String!
    newLeaderId: ID
    oldLeaderId: ID
    newBishopId: ID
    oldBishopId: ID
  ): Campus
    @cypher(
      statement: """
      MATCH  (campusTown {id: $campusTownId}) WHERE campusTown:Campus OR campusTown:Town
      MATCH (admin:Member {auth_id: $auth.jwt.sub})
      CREATE (log:HistoryLog {id: apoc.create.uuid()})
        SET log.historyRecord = $historyRecord,
          log.timeStamp = datetime()
      MERGE (date:TimeGraph {date: date()})
      MERGE (campusTown)-[r:HAS_HISTORY]->(log)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (log)-[:LOGGED_BY]->(admin)

      WITH log,campusTown
      CALL{
        WITH log
        WITH log WHERE $newLeaderId IS NOT NULL
      MATCH (newLeader:Member {id: $newLeaderId})
        SET log :ServiceLog
        WITH log, newLeader
      OPTIONAl MATCH ()-[r0:HAS_HISTORY]->(log)
        SET r0.current = false
        WITH log,newLeader
      CREATE (newLeader)-[r:HAS_HISTORY]->(log)
         SET r.current = true
         WITH log
      RETURN COUNT(log)
      }

      WITH log,campusTown
      CALL {
        WITH log
        WITH log WHERE $oldLeaderId IS NOT NULL
        MATCH (oldLeader:Member {id: $oldLeaderId})
        CREATE (oldLeader)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }


      WITH log,campusTown
      CALL {
        WITH log
        WITH log WHERE $oldBishopId IS NOT NULL
        MATCH (bishop:Member {id: $oldBishopId})
        MERGE (bishop)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      WITH log,campusTown
      CALL {
        WITH log
        WITH log WHERE $newBishopId IS NOT NULL
        MATCH (bishop:Member {id: $newBishopId})
        MERGE (bishop)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      RETURN campusTown
      """
    )
  LogSontaHistory(
    sontaId: ID!
    historyRecord: String!
    newLeaderId: ID
    oldLeaderId: ID
  ): Sonta
    @cypher(
      statement: """
       MATCH  (sonta:Sonta {id: $sontaId})
       MATCH (admin:Member {auth_id: $auth.jwt.sub})
       CREATE (log:HistoryLog {id: apoc.create.uuid()})
         SET log.historyRecord = $historyRecord,
           log.timeStamp = datetime()
       MERGE (date:TimeGraph {date: date()})
       MERGE (sonta)-[r:HAS_HISTORY]->(log)
       MERGE (log)-[:RECORDED_ON]->(date)
       MERGE (log)-[:LOGGED_BY]->(admin)

       WITH log,sonta
       CALL{
         WITH log
         WITH log WHERE $newLeaderId IS NOT NULL
       MATCH (newLeader:Member {id: $newLeaderId})
      OPTIONAL MATCH (oldLeader:Member {id: $oldLeaderId})
         SET log :ServiceLog
         WITH log, newLeader,oldLeader
       OPTIONAl MATCH ()-[r0:HAS_HISTORY]->(log)
         SET r0.current = false
         WITH log,newLeader,oldLeader
       CREATE (oldLeader)-[:HAS_HISTORY]->(log)
       CREATE (newLeader)-[r:HAS_HISTORY]->(log)
          SET r.current = true
          WITH log
       RETURN COUNT(log)
       }


       RETURN sonta
      """
    )

  #SERVICE RECORDS MUTATIONS
  RecordService(
    id: ID!
    serviceDate: String!
    attendance: Int!
    income: Float!
    foreignCurrency: String
    numberOfTithers: Int
    treasurers: [ID]!
    treasurerSelfie: String!
    servicePicture: String!
  ): ServiceRecord
    @cypher(
      statement: """
      CREATE (serviceRecord:ServiceRecord {created_at:datetime()})
        SET serviceRecord.id = apoc.create.uuid(),
        serviceRecord.attendance = $attendance,
        serviceRecord.income = $income,
        serviceRecord.foreignCurrency = $foreignCurrency,
        serviceRecord.numberOfTithers = $numberOfTithers,
        serviceRecord.treasurerSelfie = $treasurerSelfie,
        serviceRecord.servicePicture = $servicePicture
      WITH serviceRecord
      MATCH (church {id:$id}) WHERE church:Bacenta OR church:Centre OR church:Campus OR church:Town
      MATCH (church)-[has_history:HAS_HISTORY]->(log:HistoryLog) WHERE has_history.current = true
      MATCH (leader:Member {auth_id: $auth.jwt.sub})

      MERGE (serviceRecord)-[:LOGGED_BY]->(leader)
      MERGE (serviceDate:TimeGraph {date:date($serviceDate)})
      MERGE (serviceRecord)-[:SERVICE_HELD_ON]->(serviceDate)
      MERGE (log)-[:HAS_RECORD]->(serviceRecord)

      WITH serviceRecord
      UNWIND $treasurers AS treasurerId WITH treasurerId, serviceRecord
      MATCH (treasurer:Member {id: treasurerId})
      MERGE (treasurer)-[:WAS_TREASURER_FOR]->(serviceRecord)

      RETURN serviceRecord
      """
    )

  RecordCancelledService(
    id: ID!
    serviceDate: String!
    noServiceReason: String!
  ): NoService
    @cypher(
      statement: """
      CREATE (serviceRecord:ServiceRecord:NoService {created_at:datetime()})
        SET serviceRecord.id = apoc.create.uuid(),
        serviceRecord.noServiceReason = $noServiceReason

      WITH serviceRecord
      MATCH (church {id:$id}) WHERE church:Bacenta OR church:Centre OR church:Campus OR church:Town
      MATCH (church)-[has_history:HAS_HISTORY]->(log:HistoryLog) WHERE has_history.current = true
      MATCH (leader:Member {auth_id: $auth.jwt.sub})

      MERGE (serviceRecord)-[:LOGGED_BY]->(leader)
      MERGE (serviceDate:TimeGraph {date:date($serviceDate)})
      MERGE (serviceRecord)-[:SERVICE_HELD_ON]->(serviceDate)
      MERGE (log)-[:HAS_RECORD]->(serviceRecord)

      RETURN serviceRecord
      """
    )

  RecordServiceNoOffering(
    id: ID!
    serviceDate: String!
    attendance: Int!
    servicePicture: String!
  ): ServiceRecord
    @cypher(
      statement: """
      CREATE (serviceRecord:ServiceRecord {created_at:datetime()})
        SET serviceRecord.id = apoc.create.uuid(),
        serviceRecord.attendance = $attendance,
        serviceRecord.servicePicture = $servicePicture
      WITH serviceRecord
      MATCH (church {id:$id}) WHERE church:Bacenta OR church:Centre OR church:Sonta OR church:Campus OR church:Town
      MATCH (church)-[has_history:HAS_HISTORY]->(log:HistoryLog) WHERE has_history.current = true
      MATCH (leader:Member {auth_id: $auth.jwt.sub})

      MERGE (serviceRecord)-[:LOGGED_BY]->(leader)
      MERGE (serviceDate:TimeGraph {date:date($serviceDate)})
      MERGE (serviceRecord)-[:SERVICE_HELD_ON]->(serviceDate)
      MERGE (log)-[:HAS_RECORD]->(serviceRecord)

      RETURN serviceRecord
      """
    )

  #Set Bacenta to be 'OnVacation
  SetBacentaOnVacation(bacentaId: ID!): Bacenta
    @cypher(
      statement: """
      MATCH (bacenta:Bacenta {id:$bacentaId})
      OPTIONAL MATCH (bacenta)-[:HAS_BACENTA]-(centre)
      MATCH (admin:Member {auth_id: $auth.jwt.sub})

      CREATE (log:HistoryLog {id:apoc.create.uuid()})
        SET log.timeStamp = datetime(),
        log.historyRecord = bacenta.name + ' Bacenta was closed down under ' + centre.name +' Centre'


      MERGE (date:TimeGraph {date:date()})
      MERGE (log)-[:LOGGED_BY]->(admin)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (bacenta)-[:HAS_HISTORY]->(log)
      MERGE (centre)-[:HAS_HISTORY]->(log)

      SET bacenta:ClosedBacenta
      REMOVE bacenta:Bacenta

      RETURN bacenta
      """
    )

  #DELETE OPERATIONS
  # In the context of church data we never delete, we only render inactive
  CloseDownBacenta(bacentaId: ID!): Bacenta
    @cypher(
      statement: """
      MATCH (bacenta:Bacenta {id:$bacentaId})
      OPTIONAL MATCH (bacenta)-[:HAS_BACENTA]-(centre)
      MATCH (admin:Member {auth_id: $auth.jwt.sub})

      CREATE (log:HistoryLog {id:apoc.create.uuid()})
        SET log.timeStamp = datetime(),
        log.historyRecord = bacenta.name + ' Bacenta was closed down under ' + centre.name +' Centre'


      MERGE (date:TimeGraph {date:date()})
      MERGE (log)-[:LOGGED_BY]->(admin)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (bacenta)-[:HAS_HISTORY]->(log)
      MERGE (centre)-[:HAS_HISTORY]->(log)

      SET bacenta:ClosedBacenta
      REMOVE bacenta:Bacenta

      RETURN bacenta
      """
    )

  CloseDownCentre(centreId: ID!): Centre
    @cypher(
      statement: """
      MATCH (centre:Centre {id:$centreId})
      MATCH (admin:Member {auth_id: $auth.jwt.sub})
      OPTIONAL MATCH (centre)-[:HAS_CENTRE]-(campusTown)
      OPTIONAL MATCH (centre)-[:HAS_BACENTA]->(bacentas)
      UNWIND labels(campusTown) AS stream

      CREATE (log:HistoryLog {id:apoc.create.uuid()})
        SET log.timeStamp = datetime(),
        log.historyRecord = centre.name + ' Centre was closed down under ' + campusTown.name +' '+stream


      MERGE (date:TimeGraph {date:date()})
      MERGE (log)-[:LOGGED_BY]->(admin)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (centre)-[:HAS_HISTORY]->(log)
      MERGE (campusTown)-[:HAS_HISTORY]->(log)

      SET centre:ClosedCentre, bacentas:ClosedBacenta
      REMOVE centre:Centre,  bacentas:Bacenta


      RETURN centre
      """
    )

  CloseDownCampusTown(campusTownId: ID!): Constituency
    @cypher(
      statement: """
      MATCH (campusTown {id:$campusTownId}) WHERE campusTown:Campus OR campusTown:Town
      MATCH (admin:Member {auth_id: $auth.jwt.sub})
      OPTIONAL MATCH (campusTown)-[:HAS_CAMPUS|HAS_TOWN]-(bishop)
      OPTIONAL MATCH (campusTown)-[:HAS_CENTRE]->(centres)-[:HAS_BACENTA]->(bacentas)
      UNWIND labels(campusTown) AS stream

      CREATE (log:HistoryLog {id:apoc.create.uuid()})
        SET log.timeStamp = datetime(),
        log.historyRecord = campusTown.name + ' '+stream +' was closed down under Bishop ' + bishop.firstName +' '+bishop.lastName


      MERGE (date:TimeGraph {date:date()})
      MERGE (log)-[:LOGGED_BY]->(admin)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (campusTown)-[:HAS_HISTORY]->(log)
      MERGE (bishop)-[:HAS_HISTORY]->(log)

      SET campusTown:ClosedCampusTown, centres:ClosedCentre, bacentas:ClosedBacenta
      REMOVE campusTown:Campus:Town,centres:Centre,bacentas:Bacenta

      RETURN campusTown
      """
    )

  #CHURCH CONVERSIONS
  MakeBacentaIntoCentre(bacentaId: ID!): Centre
    @cypher(
      statement: """
      MATCH (bacenta:Bacenta {id:$bacentaId})
      MATCH (admin:Member {auth_id: $auth.jwt.sub})
      CREATE (newBacenta:Bacenta {id:apoc.create.uuid()})
       SET newBacenta.name = bacenta.name,
       newBacenta.location = bacenta.location
      CREATE (log:HistoryLog {id:apoc.create.uuid()})
        SET log.timeStamp = datetime(),
        log.historyRecord = bacenta.name + ' was made into a Centre with '+ newBacenta.name+' as a bacenta under it.'

      WITH newBacenta, log, bacenta
      MATCH (bacenta)<-[hasBacenta:HAS_BACENTA]-(:Centre)<-[:HAS_CENTRE]-(campusTown)
      MATCH (bacenta)-[meetsOnDay:MEETS_ON]->(meetingDay)
      MATCH (bacenta)<-[belongsTo:BELONGS_TO]-(member:Member)
      MATCH (bacenta)<-[:LEADS]-(leader:Member)

      MERGE (date:TimeGraph {date:date()})
      MERGE (campusTown)-[:HAS_CENTRE]->(bacenta)
      MERGE (newBacenta)-[:MEETS_ON]->(meetingDay)
      MERGE (newBacenta)<-[:LEADS]-(leader)
      MERGE (member)-[:BELONGS_TO]->(newBacenta)
      MERGE (bacenta)-[:HAS_BACENTA]->(newBacenta)

      DELETE hasBacenta,meetsOnDay,belongsTo

      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (log)-[:LOGGED_BY]->(admin)
      MERGE (bacenta)-[:HAS_HISTORY]->(log)
      MERGE (newBacenta)-[:HAS_HISTORY]->(log)

      SET bacenta:Centre
      REMOVE bacenta.location
      REMOVE bacenta:Bacenta
      RETURN bacenta
      """
    )
}
