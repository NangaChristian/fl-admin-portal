type Member {
  id: ID!
  auth_id: String
  firstName: String #@search
  middleName: String
  lastName: String
  fullName: String @ignore
  email: String
  phoneNumber: String
  whatsappNumber: String
  pictureUrl: String
  gender: Gender @relationship(type: "HAS_GENDER", direction: OUT)
  maritalStatus: MaritalStatus
    @relationship(type: "HAS_MARITAL_STATUS", direction: OUT)
  dob: TimeGraph @relationship(type: "WAS_BORN_ON", direction: OUT)
  title: [Title]
    @relationship(type: "HAS_TITLE", properties: "HasTitle", direction: OUT)
  ministry: Ministry @relationship(type: "BELONGS_TO", direction: OUT)
  occupation: Occupation @relationship(type: "HAS_OCCUPATION", direction: OUT)
  # Church Details
  members: [Member]
    @cypher(
      statement: """
      MATCH (this)-[:LEADS|HAS|IS_ADMIN_FOR*1..4]->(:Bacenta)-[:BELONGS_TO]-(members)
      RETURN DISTINCT members
      """
    )
  memberCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:LEADS|HAS|IS_ADMIN_FOR*1..4]->(:Bacenta)-[:BELONGS_TO]-(members)
      RETURN COUNT(DISTINCT members)
      """
    )
  basontaMembers: [Member]
    @cypher(
      statement: """
      MATCH (this)-[:LEADS|HAS|IS_ADMIN_FOR*1..4]->(:Bacenta)-[:BELONGS_TO]-(members)
      MATCH (members)-[:BELONGS_TO]->(:Ministry)
      RETURN DISTINCT members
      """
    )
  basontaMembershipCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:LEADS|HAS|IS_ADMIN_FOR*1..4]->(:Bacenta)-[:BELONGS_TO]-(members)
      MATCH (members)-[:BELONGS_TO]->(:Ministry)
      RETURN COUNT(DISTINCT members)
      """
    )
  history: [HistoryLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  loggedHistory: [HistoryLog] @relationship(type: "LOGGED_BY", direction: IN)
  bacenta: Bacenta @relationship(type: "BELONGS_TO", direction: OUT)
  leadsBacenta: [Bacenta] @relationship(type: "LEADS", direction: OUT)
  leadsCentre: [Centre] @relationship(type: "LEADS", direction: OUT)
  leadsMinistry: [Ministry] @relationship(type: "LEADS", direction: OUT)
  leadsSonta: [Sonta] @relationship(type: "LEADS", direction: OUT)
  leadsBasonta: [Basonta] @relationship(type: "LEADS", direction: OUT)
  leadsTown: [Town] @relationship(type: "LEADS", direction: OUT)
  leadsCampus: [Campus] @relationship(type: "LEADS", direction: OUT)
  isBishopForTown: [Town] @relationship(type: "HAS", direction: OUT)
  isBishopForCampus: [Campus] @relationship(type: "HAS", direction: OUT)
  isAdminForCouncil: [Council]
    @relationship(type: "IS_ADMIN_FOR", direction: OUT) #@neo4j_ignore
  isAdminForCampus: [Campus] @relationship(type: "IS_ADMIN_FOR", direction: OUT)
  isAdminForTown: [Town] @relationship(type: "IS_ADMIN_FOR", direction: OUT)

  #OTHER WORKS
  was_treasurer_for: [ServiceRecord]!
    @relationship(type: "WAS_TREASURER_FOR", direction: OUT)
}

extend type Member @auth(rules: [{ isAuthenticated: true }])
extend type Bacenta @auth(rules: [{ isAuthenticated: true }])
extend type Centre @auth(rules: [{ isAuthenticated: true }])
extend type Campus @auth(rules: [{ isAuthenticated: true }])
extend type Town @auth(rules: [{ isAuthenticated: true }])
extend type Sonta @auth(rules: [{ isAuthenticated: true }])
extend type Ministry @auth(rules: [{ isAuthenticated: true }])

type Gender @auth(rules: [{ isAuthenticated: true }]) {
  gender: String
  members: [Member] @relationship(type: "HAS_GENDER", direction: IN)
}

type MaritalStatus @auth(rules: [{ isAuthenticated: true }]) {
  status: String
  members: [Member] @relationship(type: "HAS_MARITAL_STATUS", direction: IN)
}

type Occupation @auth(rules: [{ isAuthenticated: true }]) {
  occupation: String
  members: [Member] @relationship(type: "HAS_OCCUPATION", direction: IN)
}

type Title @auth(rules: [{ isAuthenticated: true }]) {
  title: String! #Pastor, Reverend, Apostle, Bishop (Mother)
  members: [Member]
    @relationship(type: "HAS_TITLE", properties: "HasTitle", direction: IN)
}

interface HasTitle @relationshipProperties {
  dateAppointed: Date
}

type TimeGraph @auth(rules: [{ isAuthenticated: true }]) {
  date: Date
  memberDo: Member @relationship(type: "WAS_BORN_ON", direction: IN)
  # titleAppointmentDate: Member @relationship(type: "APPOINTED_ON", direction: IN)
  leaderHistoryStartDate: Member
    @relationship(type: "LEADER_STARTED_ON", direction: OUT)
  leaderHistoryEndDate: TimeGraph
    @relationship(type: "LEADER_ENDED_ON", direction: OUT)
  historyDate: Member @relationship(type: "RECORDED_ON", direction: OUT)
  serviceDate: [ServiceRecord]
    @relationship(type: "SERVICE_HELD_ON", direction: IN)
}

type ServiceRecord @auth(rules: [{ isAuthenticated: true }]) {
  id: ID!
  created_at: Date
  created_by: Member @relationship(type: "LOGGED_BY", direction: OUT)
  serviceDate: TimeGraph @relationship(type: "SERVICE_HELD_ON", direction: OUT)
  week: Int
    @cypher(
      statement: """
      MATCH (this)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      RETURN date(date.date).week
      """
    )
  attendance: Int
  income: Float
  foreignCurrency: String
  servicePicture: String
  treasurerSelfie: String
  bankingSlip: String
  treasurers: [Member]! @relationship(type: "WAS_TREASURER_FOR", direction: IN)
  serviceLog: ServiceLog @relationship(type: "HAS_RECORD", direction: IN)
  noServiceReason: String
}

type NoService @auth(rules: [{ isAuthenticated: true }]) {
  id: ID!
  created_at: Date
  created_by: Member @relationship(type: "LOGGED_BY", direction: OUT)
  serviceDate: TimeGraph @relationship(type: "SERVICE_HELD_ON", direction: OUT)
  week: Int
    @cypher(
      statement: """
      MATCH (this)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      RETURN date(date.date).week
      """
    )
  historyLog: HistoryLog @relationship(type: "HAS_RECORD", direction: IN)
  noServiceReason: String
}

type ServiceLog @auth(rules: [{ isAuthenticated: true }]) {
  id: ID
  historyRecord: String #leader was transferred to
  created_at: TimeGraph @relationship(type: "RECORDED_ON", direction: OUT)
  loggedBy: Member @relationship(type: "LOGGED_BY", direction: OUT)
  serviceRecords: [ServiceRecord]
    @relationship(type: "HAS_RECORD", direction: OUT)
  leaders: [Member] @relationship(type: "HAS_HISTORY", direction: IN)
  bacenta: [Bacenta] @relationship(type: "HAS_HISTORY", direction: IN)
  centre: [Centre] @relationship(type: "HAS_HISTORY", direction: IN)
  # centreBacentaRecords(centreId: ID!): [CentreBacentaServiceRecords]
  campus: [Campus] @relationship(type: "HAS_HISTORY", direction: IN)
  town: [Town] @relationship(type: "HAS_HISTORY", direction: IN)
  sonta: [Sonta] @relationship(type: "HAS_HISTORY", direction: IN)
}

type ComponentServiceAggregate {
  week: Int!
  attendance: Int!
  income: Float!
}

type HistoryLog @auth(rules: [{ isAuthenticated: true }]) {
  id: ID @id
  timeStamp: DateTime
  historyRecord: String #leader was transferred to
  created_at: TimeGraph @relationship(type: "RECORDED_ON", direction: OUT)
  loggedBy: Member @relationship(type: "LOGGED_BY", direction: OUT)
  leaders: [Member] @relationship(type: "HAS_HISTORY", direction: IN)
  bacenta: [Bacenta] @relationship(type: "HAS_HISTORY", direction: IN)
  centre: [Centre] @relationship(type: "HAS_HISTORY", direction: IN)
  campus: [Campus] @relationship(type: "HAS_HISTORY", direction: IN)
  town: [Town] @relationship(type: "HAS_HISTORY", direction: IN)
  sonta: [Sonta] @relationship(type: "HAS_HISTORY", direction: IN)
}

# Campus-Centre, Town-Centre
type Constituency {
  id: ID @id
  name: String
  leader: Member @relationship(type: "LEADS", direction: IN)
  sontas: [Sonta] @relationship(type: "HAS_SONTA", direction: OUT)
  centres: [Centre] @relationship(type: "HAS", direction: OUT)
  campusBishop: Member @relationship(type: "HAS", direction: IN)
  townBishop: Member @relationship(type: "HAS", direction: IN)
  admin: Member @relationship(type: "IS_ADMIN_FOR", direction: IN)
  history: [HistoryLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  serviceRecord: [ServiceRecord]
    @relationship(type: "HAS_RECORD", direction: OUT)
  serviceLogs: [ServiceLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  componentServiceAggregate: [ComponentServiceAggregate] @ignore
}

type Council {
  id: ID @id
  name: String!
  leader: Member @relationship(type: "LEADS", direction: IN)
  towns: [Town] @relationship(type: "HAS", direction: OUT)
  campuses: [Campus] @relationship(type: "HAS", direction: OUT)
  centres: [Centre]
    @cypher(
      statement: "MATCH (this)-[:HAS*1..2]->(centre:Centre) RETURN centre"
    )
  constituencies: [Constituency] @relationship(type: "HAS", direction: OUT)
  members: [Member]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*1..4]->(:Bacenta)<-[:BELONGS_TO]-(members:Member)
      RETURN DISTINCT members
      """
    )
  memberCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*1..4]->(:Bacenta)<-[:BELONGS_TO]-(members:Member)
      RETURN COUNT(DISTINCT members)
      """
    )
  pastorCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*1..4]->(:Bacenta)<-[:BELONGS_TO]-(pastors:Member)-[:HAS_TITLE]->(:Title)
      RETURN COUNT(DISTINCT pastors)
      """
    )
  constituencyCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS]->(constituency) WHERE constituency:Campus OR constituency:Town RETURN COUNT(constituency)"
    )
  centreCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*2]->(centres:Centre) RETURN COUNT(DISTINCT centres)"
    )
  bacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*3]->(bacentas:Bacenta) RETURN COUNT(DISTINCT bacentas)"
    )
  admin: Member @relationship(type: "IS_ADMIN_FOR", direction: IN)
  history: [HistoryLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  serviceRecord: [ServiceRecord]
    @relationship(type: "HAS_RECORD", direction: OUT)
  serviceLogs: [ServiceLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  componentServiceAggregate: [ComponentServiceAggregate] @ignore
}

type Campus {
  id: ID @id
  name: String
  members: [Member]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*1..4]->(bacenta:Bacenta)<-[:BELONGS_TO]-(members:Member)
      RETURN DISTINCT members
      """
    )
  memberCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*1..4]->(bacenta:Bacenta)<-[:BELONGS_TO]-(members:Member)
      RETURN COUNT(DISTINCT members)
      """
    )
  bacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS]-(:Centre)-[:HAS]->(bacenta:Bacenta) RETURN COUNT(bacenta)"
    )
  leader: Member @relationship(type: "LEADS", direction: IN)
  sontas: [Sonta] @relationship(type: "HAS_SONTA", direction: OUT)
  centres: [Centre] @relationship(type: "HAS", direction: OUT)
  council: Council @relationship(type: "HAS", direction: IN)
  bishop: Member
    @cypher(
      statement: "MATCH (this)-[:HAS]-(:Council)-[:LEADS]-(bishop:Member) RETURN bishop"
    )
  admin: Member @relationship(type: "IS_ADMIN_FOR", direction: IN)
  history: [HistoryLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  serviceRecord: [ServiceRecord]
    @relationship(type: "HAS_RECORD", direction: OUT)
  serviceLogs: [ServiceLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  componentServiceAggregate: [ComponentServiceAggregate] @ignore
}

type Town {
  id: ID @id
  name: String
  members: [Member]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*1..4]->(bacenta:Bacenta)<-[:BELONGS_TO]-(members:Member)
      RETURN DISTINCT members
      """
    )
  memberCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*1..4]->(bacenta:Bacenta)<-[:BELONGS_TO]-(members:Member)
      RETURN COUNT(DISTINCT members)
      """
    )
  bacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS]-(:Centre)-[:HAS]->(bacenta:Bacenta) RETURN COUNT(bacenta)"
    )
  leader: Member @relationship(type: "LEADS", direction: IN)
  sontas: [Sonta] @relationship(type: "HAS_SONTA", direction: OUT)
  centres: [Centre] @relationship(type: "HAS", direction: OUT)
  council: Council @relationship(type: "HAS", direction: IN)
  bishop: Member
    @cypher(
      statement: "MATCH (this)-[:HAS]-(:Council)-[:LEADS]-(bishop:Member) RETURN bishop"
    )
  admin: Member @relationship(type: "IS_ADMIN_FOR", direction: IN)
  history: [HistoryLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  serviceRecord: [ServiceRecord]
    @relationship(type: "HAS_RECORD", direction: OUT)
  serviceLogs: [ServiceLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  componentServiceAggregate: [ComponentServiceAggregate] @ignore
}

type Centre {
  id: ID @id
  name: String
  members: [Member]
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(bacenta:Bacenta)<-[:BELONGS_TO]-(members:Member)
      RETURN DISTINCT members
      """
    )
  memberCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(bacenta:Bacenta)<-[:BELONGS_TO]-(members:Member)
      RETURN COUNT(DISTINCT members)
      """
    )
  leader: Member @relationship(type: "LEADS", direction: IN)
  bacentas: [Bacenta] @relationship(type: "HAS", direction: OUT)
  basontas: Basonta @relationship(type: "HAS_BASONTA", direction: OUT)
  town: Town @relationship(type: "HAS", direction: IN)
  campus: Campus @relationship(type: "HAS", direction: IN)
  history: [HistoryLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  serviceLogs: [ServiceLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  bacentaServiceAggregate: [ComponentServiceAggregate] @ignore
}

# Shared Units: Bacenta, Bacenta, Sonta
type Bacenta {
  id: ID @id
  bankingCode: String
  name: String
  location: Point
  centre: Centre @relationship(type: "HAS", direction: IN)
  leader: Member @relationship(type: "LEADS", direction: IN)
  members: [Member] @relationship(type: "BELONGS_TO", direction: IN)
  memberCount: Int
    @cypher(
      statement: """
      MATCH (this)<-[:BELONGS_TO]-(members:Member)
      RETURN COUNT(DISTINCT members)
      """
    )
  meetingDay: ServiceDay @relationship(type: "MEETS_ON", direction: OUT)
  history: [HistoryLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  serviceLogs: [ServiceLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  services: [ServiceRecord]
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(services:ServiceRecord)
      RETURN services
      """
    )
  labels: [String]
    @cypher(
      statement: """
      MATCH (this)
      RETURN labels(this)
      """
    )
}

type ServiceDay @auth(rules: [{ isAuthenticated: true }]) {
  day: String!
  dayNumber: Int
  bacenta: Bacenta @relationship(type: "MEETS_ON", direction: IN)
}

type Ministry {
  id: ID @id
  name: String
  sonta: [Sonta] @relationship(type: "HAS_SONTA", direction: OUT)
  leader: Member @relationship(type: "LEADS", direction: IN)
  members: [Member] @relationship(type: "BELONGS_TO", direction: IN)
}

type Sonta {
  id: ID @id
  name: String
  leader: Member @relationship(type: "LEADS", direction: IN)
  basonta: [Basonta] @relationship(type: "HAS_BASONTA", direction: OUT)
  ministry: Ministry @relationship(type: "HAS_SONTA", direction: IN)
  town: Town @relationship(type: "HAS_SONTA", direction: IN)
  history: [HistoryLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  campus: Campus @relationship(type: "HAS_SONTA", direction: IN)
  serviceLogs: [ServiceLog] @relationship(type: "HAS_HISTORY", direction: OUT)
}
type Basonta {
  id: ID @id
  name: String
  leader: Member @relationship(type: "LEADS", direction: IN)
  centre: Centre @relationship(type: "HAS_BASONTA", direction: IN)
  sonta: Sonta @relationship(type: "HAS_BASONTA", direction: IN)
}

#Query Definitions
type Query {
  #At the Federal Level

  #At the Episcopal Level
  bishopCampusTownCount(id: ID): Int!
    @cypher(
      statement: "MATCH (:Member {id: $id})-[:HAS]->(campusTown) WHERE campusTown:Campus OR campusTown:Town RETURN COUNT(DISTINCT campusTown)"
    )
  bishopCentreCount(id: ID): Int!
    @cypher(
      statement: "MATCH (:Member {id: $id})-[:HAS]->()-[:HAS]-(centre:Centre) RETURN COUNT(DISTINCT centre)"
    )
  bishopBacentaCount(id: ID): Int!
    @cypher(
      statement: "MATCH (:Member {id: $id})-[:HAS]->()-[:HAS]->(:Centre)-[:HAS]-(bacenta:Bacenta) RETURN COUNT(DISTINCT bacenta)"
    )
  bishopBacentaDropdown(id: ID!, bacentaName: String!): [Bacenta]
    @cypher(
      statement: "MATCH (bacenta:Bacenta)<-[]-(:Centre)<-[:HAS]-()<-[:HAS]-(:Member {id: $id}) WHERE toLower(bacenta.name) CONTAINS toLower($bacentaName) RETURN DISTINCT bacenta LIMIT 5"
    )
  bishopsSontaMemberList(id: ID): [Member]!
    @cypher(
      statement: """
      MATCH (:Member {id: $id})-[:HAS]->()-[:HAS]->(:Centre)-[:HAS]->(:Bacenta)<-[:BELONGS_TO]-(member:Member)-[:BELONGS_TO]->(:Ministry)
      RETURN member
      """
    )
  bishopSontamembershipCount(id: ID): Int!
    @cypher(
      statement: """
      MATCH (:Member {id: $id})-[:HAS]->()-[:HAS]->(:Centre)-[:HAS]->(:Bacenta)<-[:BELONGS_TO]-(member:Member)-[:BELONGS_TO]->(:Ministry)
      RETURN COUNT(DISTINCT member)
      """
    )
  bishopSontamembershipCountList(bishopId: ID): [Ministry]!
    @cypher(
      statement: """
      MATCH (:Member {id: $bishopId})-[:HAS]->()-[:HAS]->(:Centre)-[:HAS]->(:Bacenta)<-[:BELONGS_TO]-(m:Member)-[:BELONGS_TO]->(ministry:Ministry)
      RETURN ministry, COUNT(DISTINCT member)
      """
    )
  bishopPastorCount(id: ID): Int!
    @cypher(
      statement: "MATCH (title:Title)<-[:HAS_TITLE]-(member:Member)-[:BELONGS_TO]->(:Bacenta)<-[:HAS]-(:Centre)-[:HAS]-()-[:HAS]-(:Member {id: $id}) RETURN COUNT( DISTINCT member)"
    )

  councilCentreDropdown(id: ID!, nameSearch: String!): [Centre]
    @cypher(
      statement: """
      MATCH (:Council {id: $id})-[:HAS]->(campusTown) WHERE campusTown:Campus OR campusTown:Town
      MATCH (campusTown)-[:HAS]->(centre:Centre)
      WHERE toLower(centre.name) CONTAINS toLower($nameSearch)
      RETURN centre LIMIT 5
      """
    )

  councilMemberDropdown(id: ID!, nameSearch: String!): [Member]
    @cypher(
      statement: """
      MATCH (:Council {id: $id})-[:HAS]->(campusTown) WHERE campusTown:Town OR campusTown:Campus
      MATCH (campusTown)-[:HAS]->(:Centre)-[:HAS]->(:Bacenta)<-[:BELONGS_TO]-(member:Member)
      WHERE toLower(member.firstName+ ' ' + member.lastName) CONTAINS toLower($nameSearch)
      RETURN member LIMIT 5
      """
    )

  #At the Town Level
  townSontaList(id: ID): [Sonta]
    @cypher(
      statement: "MATCH (town:Town {id: $id})-[:HAS_SONTA]->(sonta:Sonta)  RETURN sonta"
    )
  townCentreCount(id: ID): Int!
    @cypher(
      statement: "MATCH(:Town {id:$id})-[:HAS]->(centre:Centre) RETURN COUNT(centre)"
    )
  townSontaCount(id: ID): Int!
    @cypher(
      statement: "MATCH (:Town {id:$id})-[:HAS_SONTA]->(sonta:Sonta) RETURN COUNT(sonta)"
    )
  townSontamembershipCount(id: ID): Int!
    @cypher(
      statement: "MATCH (:Town {id: $id})-[]-(:Centre)-[]->(:Bacenta)<-[:BELONGS_TO]-(member:Member) MATCH (member)-[:BELONGS_TO]->(:Ministry) RETURN COUNT(DISTINCT member)"
    )

  #At the Campus Level
  campusBacentaList(id: ID): [Bacenta]
    @cypher(
      statement: "MATCH (campus:Campus {id: $id})-[:HAS]->(:Centre)-[:HAS]-> (bacenta:Bacenta) RETURN bacenta"
    )
  campusSontaList(id: ID): [Sonta]
    @cypher(
      statement: "MATCH (campus:Campus {id: $id})-[:HAS_SONTA]->(sonta:Sonta)  RETURN sonta"
    )
  campusCentreList(id: ID): [Centre]
    @cypher(
      statement: "MATCH (t:Campus {id:$id})-[:HAS]->(centre:Centre) RETURN centre"
    )
  campusCentreCount(id: ID): Int!
    @cypher(
      statement: "MATCH(:Campus {id:$id})-[:HAS]->(centre:Centre) RETURN COUNT(centre)"
    )
  campusSontaCount(id: ID): Int!
    @cypher(
      statement: "MATCH (:Campus {id:$id})-[:HAS_MINISTRY]->(sonta:Sonta) RETURN COUNT(sonta)"
    )

  campusSontamembershipCount(id: ID): Int!
    @cypher(
      statement: "MATCH (:Campus {id: $id})-[]-(:Centre)-[]->(:Bacenta)<-[:BELONGS_TO]-(member:Member) MATCH (member)-[:BELONGS_TO]->(:Ministry) RETURN COUNT(DISTINCT member)"
    )

  #At the Centre Level
  centreDropdown(centreName: String): [Centre]
    @cypher(
      statement: "MATCH (centre:Centre) WHERE toLower(centre.name) CONTAINS toLower($centreName) RETURN centre LIMIT 5"
    )
  centreBacentaList(id: ID): [Bacenta]
    @cypher(
      statement: """
      MATCH (bacenta:Bacenta)
      WHERE (:Centre {id:$id})-[:HAS]->(bacenta)
      RETURN bacenta
      """
    )
  centreBacentaCount(id: ID): Int!
    @cypher(
      statement: "MATCH (:Centre {id:$id})-[:HAS]->(bacenta:Bacenta) RETURN COUNT(bacenta)"
    )
  centreSontaCount(id: ID): Int!
    @cypher(
      statement: "MATCH (sonta:Sonta)<-[:HAS_MINISTRY]-(:Centre {name:$centre}) RETURN COUNT(sonta)"
    )

  bacentaDropdown(bacentaName: String): [Bacenta]
    @cypher(
      statement: "MATCH (bacenta:Bacenta) WHERE toLower(bacenta.name) CONTAINS toLower($bacentaName) RETURN DISTINCT bacenta LIMIT 5"
    )

  #At the Ministry Level
  sontaTownList(bishopId: ID, ministryId: ID): [Town]
    @cypher(
      statement: """
      MATCH (ministry:Ministry {id: $ministryId})<-[:BELONGS_TO]-(member:Member)
      MATCH (member)-[:BELONGS_TO]->(:Bacenta)<-[:HAS]-()<-[:HAS]-(campusTown)
      MATCH (campusTown)<-[:HAS|HAS]-(:Member {id: $bishopId})
      RETURN DISTINCT campusTown,ministry
      """
    )

  #At the Sonta Level
  sontaList: [Sonta] @cypher(statement: "MATCH (s:Sonta) RETURN s")
  townSontaLeader(bishopId: ID): [Member]
    @cypher(
      statement: """
      MATCH (ministry:Ministry)<-[:BELONGS_TO]-(member:Member)
      MATCH (member)-[:BELONGS_TO]->(:Bacenta)<-[:HAS]-()<-[:HAS]-(campusTown)
      MATCH (campusTown)<-[:HAS|HAS]-(:Member {id: $bishopId})
      MATCH (campusTown)-[:HAS_SONTA]->(s:Sonta {id:$sontaId})<-[:LEADS]-(sontaLeader:Member)
      WHERE sonta.name CONTAINS campusTown.name
         RETURN DISTINCT sontaLeader
      """
    )

  sontaBasontaLeaderList(id: ID): [Member]
    @cypher(
      statement: """
      MATCH (sonta:Sonta {id: $id})
      MATCH (basonta:Basonta)<-[:HAS_BASONTA]-(sonta)
      MATCH (basonta)<-[:LEADS]-(leader)
      RETURN leader
      """
    )

  #Members
  # Display Member based on ID
  currentUser(id: ID): Member
    @cypher(
      statement: "MATCH (member:Member {auth_id: $auth.jwt.sub}) RETURN member"
    )
    @auth(rules: [{ isAuthenticated: true }])

  member(id: ID!): Member
    @cypher(statement: "MATCH (member:Member {id:$id}) RETURN member LIMIT 1")
  memberByEmail(email: String!): Member
    @cypher(
      statement: "MATCH (member:Member {email:$email}) RETURN member LIMIT 1"
    )

  #DASHBOARD QUERIES
  leadsBacentaCount(id: ID!): Int
    @cypher(
      statement: """
      MATCH (member:Member {id:$id})
      MATCH (member)-[:LEADS]-(bacentas:Bacenta)
      RETURN COUNT(bacentas)
      """
    )
  leadsCentreCount(id: ID!): Int
    @cypher(
      statement: """
      MATCH (member:Member {id:$id})
      MATCH (member)-[:LEADS]-(centres:Centre)
      RETURN COUNT(centres)
      """
    )
  leadsConstituencyCount(id: ID!): Int
    @cypher(
      statement: """
      MATCH (member:Member {id:$id})
      MATCH (member)-[:LEADS|IS_ADMIN_FOR]-(constituency) WHERE constituency:Campus OR constituency:Town
      RETURN COUNT(DISTINCT constituency)
      """
    )

  bishopConstituencyCount(id: ID!): Int
    @cypher(
      statement: """
      MATCH (member:Member {id:$id})
      MATCH (member)-[:LEADS|HAS|IS_ADMIN_FOR*1..2]->(constituency) WHERE constituency:Campus OR constituency:Town
      RETURN COUNT(DISTINCT constituency)
      """
    )

  #Fuzzy Search
  memberGridList(
    gender: String
    maritalStatus: String
    ministryId: ID
    leaderTitle: String
    leaderRank: String
  ): [Member]
    @cypher(
      statement: """
      MATCH (member:Member)
      WHERE (member)-[:HAS_GENDER]->(:Gender{gender:$gender})
      OR (member)-[:HAS_MARITAL_STATUS]->(:MaritalStatus{status:$maritalStatus})
      RETURN member
      """
    )

  federalMemberSearch(searchKey: String): [Member]
    @auth(rules: [{ roles: ["adminFederal"] }])
    @cypher(
      statement: """
      MATCH (member:Member)
      WHERE toLower(member.firstName) = toLower($searchKey)
      OR toLower(member.middleName) = toLower($searchKey)
      OR toLower(member.lastName) = toLower($searchKey)
      OR toLower(member.firstName) STARTS WITH toLower($searchKey)
      OR toLower(member.middleName) STARTS WITH toLower($searchKey)
      OR toLower(member.lastName) STARTS WITH toLower($searchKey)
      OR toLower(member.firstName + ' ' + member.middleName+ ' '+ member.lastName) CONTAINS toLower($searchKey)
      RETURN member LIMIT 5
      """
    )
  councilMemberSearch(searchKey: String, councilId: ID): [Member]
    @auth(rules: [{ roles: ["adminCouncil"] }])
    @cypher(
      statement: """
      MATCH (council:Council {id: $councilId})-[:HAS]->(campusTown)-[:HAS]->(:Centre)-[:HAS]->(:Bacenta)<-[:BELONGS_TO*]-(member:Member)
      WHERE toLower(member.firstName) = toLower($searchKey)
      OR toLower(member.lastName) = toLower($searchKey)
      OR toLower(member.firstName) STARTS WITH toLower($searchKey)
      OR toLower(member.lastName) STARTS WITH toLower($searchKey)
      OR toLower(member.firstName + ' ' + member.middleName+ ' '+ member.lastName) CONTAINS toLower($searchKey)
      WITH member WHERE member IS NOT NULL
      RETURN DISTINCT(member) LIMIT 5
      """
    )
  constituencyMemberSearch(searchKey: String, constituencyId: ID): [Member]
    @auth(rules: [{ roles: ["adminCampus", "adminTown"] }])
    @cypher(
      statement: """
      MATCH (constituency {id:$constituencyId}) WHERE constituency:Campus OR constituency:Town
      MATCH (constituency)-[:HAS]->(:Centre)-[:HAS]->(bacenta:Bacenta)<-[:BELONGS_TO]-(member:Member)
      WHERE toLower(member.firstName) = toLower($searchKey)
      OR toLower(member.lastName) = toLower($searchKey)
      OR toLower(member.firstName) STARTS WITH toLower($searchKey)
      OR toLower(member.lastName) STARTS WITH toLower($searchKey)
      OR toLower(member.firstName + ' ' + member.middleName+ ' '+ member.lastName) CONTAINS toLower($searchKey)

      RETURN member LIMIT 5
      """
    )
  centreMemberSearch(searchKey: String, centreId: ID): [Member]
    @auth(rules: [{ roles: ["leaderCentre"] }])
    @cypher(
      statement: """
      MATCH (centre:Centre {id: $centreId})-[:HAS]->(:Bacenta)<-[:BELONGS_TO]-(member:Member)
      WHERE toLower(member.firstName) = toLower($searchKey)
      OR toLower(member.lastName) = toLower($searchKey)
      OR toLower(member.firstName) STARTS WITH toLower($searchKey)
      OR toLower(member.lastName) STARTS WITH toLower($searchKey)
      OR toLower(member.firstName + ' ' + member.middleName+ ' '+ member.lastName) CONTAINS toLower($searchKey)

      RETURN member LIMIT 5
      """
    )
  bacentaMemberSearch(searchKey: String, bacentaId: ID): [Member]
    @auth(rules: [{ roles: ["leaderBacenta"] }])
    @cypher(
      statement: """
      MATCH (bacenta:Bacenta {id: $bacentaId})<-[:BELONGS_TO]-(member:Member)
      WHERE toLower(member.firstName) = toLower($searchKey)
      OR toLower(member.lastName) = toLower($searchKey)
      OR toLower(member.firstName) STARTS WITH toLower($searchKey)
      OR toLower(member.lastName) STARTS WITH toLower($searchKey)
      OR toLower(member.firstName + ' ' + member.middleName+ ' '+ member.lastName) CONTAINS toLower($searchKey)

      RETURN member LIMIT 5
      """
    )
  federalBacentaSearch(searchKey: String): [Bacenta]
    @auth(rules: [{ roles: ["adminFederal"] }])
    @cypher(
      statement: """
      MATCH (bacenta:Bacenta)
      WHERE toLower(bacenta.name) STARTS WITH toLower($searchKey)
      OR toLower(bacenta.name) CONTAINS toLower($searchKey)
      RETURN DISTINCT bacenta LIMIT 5
      """
    )
  councilBacentaSearch(searchKey: String, councilId: ID): [Bacenta]
    @auth(rules: [{ roles: ["adminCouncil"] }])
    @cypher(
      statement: """
      MATCH (council:Council {id: $councilId})-[:HAS*3]->(bacenta:Bacenta)

      WHERE toLower(bacenta.name) STARTS WITH toLower($searchKey)
      OR toLower(bacenta.name) CONTAINS toLower($searchKey)
      RETURN DISTINCT bacenta LIMIT 5
      """
    )
  constituencyBacentaSearch(searchKey: String, constituencyId: ID): [Bacenta]
    @auth(rules: [{ roles: ["adminCampus", "adminTown"] }])
    @cypher(
      statement: """
      MATCH (constituency {id:$constituencyId})-[:HAS*2]->(bacenta:Bacenta)

      WHERE toLower(bacenta.name) STARTS WITH toLower($searchKey)
      OR toLower(bacenta.name) CONTAINS toLower($searchKey)
      RETURN DISTINCT bacenta LIMIT 5
      """
    )
  centreBacentaSearch(searchKey: String, centreId: ID): [Bacenta]
    @auth(rules: [{ roles: ["leaderCentre"] }])
    @cypher(
      statement: """
      MATCH (centre:Centre {id: $centreId})-[:HAS]->(bacenta:Bacenta)
      WHERE toLower(bacenta.name) STARTS WITH toLower($searchKey)
      OR toLower(bacenta.name) CONTAINS toLower($searchKey)
      RETURN DISTINCT bacenta LIMIT 5
      """
    )
  federalCentreSearch(searchKey: String): [Centre]
    @auth(rules: [{ roles: ["adminFederal"] }])
    @cypher(
      statement: """
      MATCH (centre:Centre)
      WHERE toLower(centre.name) STARTS WITH toLower($searchKey)
      OR toLower(centre.name) CONTAINS toLower($searchKey)
      RETURN centre LIMIT 5
      """
    )
  councilCentreSearch(searchKey: String, councilId: ID): [Centre]
    @auth(rules: [{ roles: ["adminCouncil"] }])
    @cypher(
      statement: """
      MATCH (council:Council {id: $councilId})-[:HAS*2]->(centre)

      WHERE toLower(centre.name) STARTS WITH toLower($searchKey)
      OR toLower(centre.name) CONTAINS toLower($searchKey)
      RETURN centre LIMIT 5
      """
    )
  constituencyCentreSearch(searchKey: String, constituencyId: ID): [Bacenta]
    @auth(rules: [{ roles: ["adminCampus", "adminTown"] }])
    @cypher(
      statement: """
      MATCH (constituency {id:$constituencyId}) WHERE constituency:Campus OR constituency:Town
      MATCH (constituency)-[:HAS]->(centre)

      WHERE toLower(centre.name) STARTS WITH toLower($searchKey)
      OR toLower(centre.name) CONTAINS toLower($searchKey)
      RETURN centre LIMIT 5
      """
    )
  federalCampusSearch(searchKey: String): [Campus]
    @auth(rules: [{ roles: ["adminFederal"] }])
    @cypher(
      statement: """
      MATCH (campus:Campus)
      WHERE toLower(campus.name) STARTS WITH toLower($searchKey)
      OR toLower(campus.name) CONTAINS toLower($searchKey)
      RETURN campus LIMIT 5
      """
    )
  councilCampusSearch(searchKey: String, councilId: ID): [Campus]
    @auth(rules: [{ roles: ["adminCouncil"] }])
    @cypher(
      statement: """
      MATCH (council:Council {id: $councilId})-[:HAS]->(campus)

      WHERE toLower(campus.name) STARTS WITH toLower($searchKey)
      OR toLower(campus.name) CONTAINS toLower($searchKey)
      RETURN campus LIMIT 5
      """
    )
  federalTownSearch(searchKey: String): [Town]
    @auth(rules: [{ roles: ["adminFederal"] }])
    @cypher(
      statement: """
      MATCH (town:Town)
      WHERE toLower(town.name) STARTS WITH toLower($searchKey)
      OR toLower(town.name) CONTAINS toLower($searchKey)
      RETURN town LIMIT 5
      """
    )
  councilTownSearch(searchKey: String, councilId: ID): [Town]
    @auth(rules: [{ roles: ["adminCouncil"] }])
    @cypher(
      statement: """
      MATCH (council:Council {id: $councilId})-[:HAS]->(town)

      WHERE toLower(town.name) STARTS WITH toLower($searchKey)
      OR toLower(town.name) CONTAINS toLower($searchKey)
      RETURN town LIMIT 5
      """
    )
  federalSontaSearch(searchKey: String): [Sonta]
    @auth(rules: [{ roles: ["adminFederal"] }])
    @cypher(
      statement: """
      MATCH (sonta:Sonta)
      WHERE toLower(sonta.name) STARTS WITH toLower($searchKey)
      OR toLower(sonta.name) CONTAINS toLower($searchKey)
      RETURN sonta LIMIT 5
      """
    )
  councilSontaSearch(searchKey: String, councilId: ID): [Sonta]
    @auth(rules: [{ roles: ["adminCouncil"] }])
    @cypher(
      statement: """
      MATCH (council:Council {id: $councilId})-[:HAS]->(campusTown)
      MATCH (campusTown)-[:HAS_SONTA]->(sonta)

      WHERE toLower(sonta.name) STARTS WITH toLower($searchKey)
      OR toLower(sonta.name) CONTAINS toLower($searchKey)
      RETURN sonta LIMIT 5
      """
    )
  constituencySontaSearch(searchKey: String, constituencyId: ID): [Bacenta]
    @auth(rules: [{ roles: ["adminCampus", "adminTown"] }])
    @cypher(
      statement: """
      MATCH (constituency {id:$constituencyId}) WHERE constituency:Campus OR constituency:Town
      MATCH (constituency)-[:HAS_SONTA]->(sonta)

      WHERE toLower(sonta.name) STARTS WITH toLower($searchKey)
      OR toLower(sonta.name) CONTAINS toLower($searchKey)
      RETURN sonta LIMIT 5
      """
    )

  occupationList(searchKey: String!): [Occupation]
    @cypher(
      statement: "MATCH (occupation:Occupation) WHERE toLower(occupation.occupation) CONTAINS toLower($searchKey) RETURN occupation"
    )
}

#Mutation Definitions
type Mutation {
  #resolver Mutations
  MakeBishopAdmin(adminId: ID!, bishopId: ID!): Member
  RemoveBishopAdmin(adminId: ID!, bishopId: ID!): Member
  MakeTownAdmin(adminId: ID!, townId: ID!): Member
  RemoveTownAdmin(adminId: ID!, townId: ID!): Member
  MakeCampusAdmin(adminId: ID!, campusId: ID!): Member
  RemoveCampusAdmin(adminId: ID!, campusId: ID!): Member
  MakeBacentaLeader(leaderId: ID!, bacentaId: ID!): Member
  RemoveBacentaLeader(leaderId: ID!, bacentaId: ID!): Member
  MakeCentreLeader(leaderId: ID!, centreId: ID!): Member
  RemoveCentreLeader(leaderId: ID!, centreId: ID!): Member
  MakeSontaLeader(leaderId: ID!, sontaId: ID!): Member
  RemoveSontaLeader(leaderId: ID!, sontaId: ID!): Member
  MakeTownLeader(leaderId: ID!, townId: ID!): Member
  RemoveTownLeader(leaderId: ID!, townId: ID!): Member
  MakeCampusLeader(leaderId: ID!, campusId: ID!): Member
  RemoveCampusLeader(leaderId: ID!, campusId: ID!): Member

  #CREATE OPERATIONS
  # Add Member to the Database
  CreateMember(
    firstName: String!
    middleName: String
    lastName: String!
    email: String!
    phoneNumber: String!
    whatsappNumber: String!
    do: String!
    maritalStatus: String!
    gender: String!
    occupation: String
    bacenta: String!
    ministry: String
    pictureUrl: String!
  ): Member

  CreateTown(
    townName: String!
    leaderId: ID!
    bishopId: ID!
    centres: [ID]
  ): Town
    @auth(rules: [{ roles: ["adminFederal", "adminCouncil"] }])
    @cypher(
      statement: """
       CREATE (town:Town {name:$townName})
         	SET
      	town.id = apoc.create.uuid()
      WITH town
      MATCH (leader:Member {id: $leaderId})
      MATCH (currentUser:Member {auth_id:$auth.jwt.sub})
      MATCH (bishop:Member {id: $bishopId})

       CREATE (log:HistoryLog)
        SET
        log.id =  apoc.create.uuid(),
        log.timeStamp = datetime(),
        log.historyRecord = leader.firstName + ' ' +leader.lastName + ' started ' + $townName +' Town Church under Bishop '+ bishop.firstName+ ' ' + bishop.lastName

      MERGE (bishop)-[:HAS]->(town)
      MERGE (leader)-[:LEADS]->(town)

      MERGE (date:TimeGraph {date: date(date())})
      MERGE (log)-[:LOGGED_BY]->(currentUser)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (bishop)-[:HAS_HISTORY]->(log)
      MERGE (town)-[:HAS_HISTORY]->(log)
      MERGE (leader)-[r:HAS_HISTORY]->(log)
        SET r.current = true

      WITH town, bishop
      CALL {
        WITH town
        WITH town WHERE $centres <> []
        UNWIND $centres AS centreIds
        MATCH (centre:Centre {id:centreIds})
        OPTIONAL MATCH (oldCampusTown)-[r:HAS]->(centre)
        DELETE r

        MERGE (town)-[:HAS]->(centre)
        RETURN count(town)
      }

      RETURN town
      """
    )
  CreateCampus(
    campusName: String!
    leaderId: ID!
    bishopId: ID!
    centres: [ID]
  ): Campus
    @auth(rules: [{ roles: ["adminFederal", "adminCouncil"] }])
    @cypher(
      statement: """
      CREATE (campus:Campus {name:$campusName})
         	SET
      	campus.id = apoc.create.uuid()
      WITH campus
      MATCH (leader:Member {id: $leaderId})
      MATCH (currentUser:Member {auth_id:$auth.jwt.sub})
      MATCH (bishop:Member {id: $bishopId})

       CREATE (log:HistoryLog)
        SET
        log.id =  apoc.create.uuid(),
        log.timeStamp = datetime(),
        log.historyRecord = leader.firstName + ' ' +leader.lastName + ' started ' + $campusName +' Campus Church under Bishop '+ bishop.firstName+ ' ' + bishop.lastName

      MERGE (bishop)-[:HAS]->(campus)
      MERGE (leader)-[:LEADS]->(campus)

      MERGE (date:TimeGraph {date: date(date())})
      MERGE (log)-[:LOGGED_BY]->(currentUser)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (bishop)-[:HAS_HISTORY]->(log)
      MERGE (campus)-[:HAS_HISTORY]->(log)
      MERGE (leader)-[r:HAS_HISTORY]->(log)
        SET r.current = true

      WITH campus, bishop
      CALL {
        WITH campus
        WITH campus WHERE $centres <> []
        UNWIND $centres AS centreIds
        MATCH (centre:Centre {id:centreIds})
        OPTIONAL MATCH (oldCampusTown)-[r:HAS]->(centre)
        DELETE r

        MERGE (campus)-[:HAS]->(centre)
        RETURN count(campus)
      }

      RETURN campus
      """
    )

  CreateCentre(
    centreName: String!
    townCampusId: ID!
    leaderId: ID!
    bacentas: [ID]
  ): Centre  #Return town and drill down to get centre info
    @auth(
      rules: [
        { roles: ["adminFederal", "adminCouncil", "adminCampus", "adminTown"] }
      ]
    )
    @cypher(
      statement: """
      CREATE (centre:Centre {name:$centreName})
         	SET
      	centre.id = apoc.create.uuid()
      WITH centre
       MATCH (leader:Member {id:$leaderId})
       MATCH (campusTown {id:$townCampusId}) WHERE campusTown:Town OR campusTown:Campus
       MATCH (currentUser:Member {auth_id:$auth.jwt.sub})
       UNWIND labels(campusTown) AS stream

      CREATE (log:HistoryLog:ServiceLog)
      SET log.id = apoc.create.uuid(),
       log.timeStamp = datetime(),
       log.historyRecord = leader.firstName + ' ' +leader.lastName + ' started ' + centre.name +' Centre under '+ campusTown.name + ' ' + stream

       MERGE (campusTown)-[:HAS]->(centre)
       MERGE (leader)-[:LEADS]->(centre)

       MERGE (date:TimeGraph {date: date(date())})
       MERGE (log)-[:LOGGED_BY]->(currentUser)
       MERGE (log)-[:RECORDED_ON]->(date)
       MERGE (campusTown)-[:HAS_HISTORY]->(log)
       MERGE (centre)-[:HAS_HISTORY]->(log)
       MERGE (leader)-[r:HAS_HISTORY]->(log)
        SET r.current = true

       WITH centre
      CALL {
        WITH centre
        WITH centre WHERE $bacentas <> []
        UNWIND $bacentas AS bacentaIds
        MATCH (bacenta:Bacenta {id:bacentaIds})
        OPTIONAL MATCH (oldCentre)-[r:HAS]->(bacenta)
        DELETE r

        MERGE (centre)-[:HAS]->(bacenta)
        RETURN count(centre)
      }

      RETURN centre
      """
    )
  CreateSonta(ministryId: ID!, townCampusId: ID!, leaderId: ID!): Town
    @auth(
      rules: [
        { roles: ["adminFederal", "adminCouncil", "adminCampus", "adminTown"] }
      ]
    )
    @cypher(
      statement: """
      CREATE (sonta:Sonta)
         	SET
      	sonta.id = apoc.create.uuid()
      WITH sonta
       MATCH (ministry:Ministry {id:$ministryId})
       MATCH (leader:Member {id: $leaderId})
       MATCH (campusTown {id:$townCampusId}) WHERE campusTown:Town OR campusTown:Campus

       MATCH (currentUser:Member {auth_id:$auth.jwt.sub})
       UNWIND labels(campusTown) AS stream

       CREATE (log:HistoryLog:ServiceLog)
        SET log.id = apoc.create.uuid(),
         log.timeStamp = datetime(),
         log.historyRecord = leader.firstName + ' ' +leader.lastName + ' started ' + sonta.name +' Sonta under '+ campusTown.name + ' ' + stream


       SET sonta.name = campusTown.name + ' ' + ministry.name

       MERGE (ministry)-[:HAS_SONTA]->(sonta)
       MERGE (campusTown)-[:HAS_SONTA]->(sonta)
       MERGE (leader)-[:LEADS]->(sonta)

      MERGE (date:TimeGraph {date: date(date())})
      MERGE (log)-[:LOGGED_BY]->(currentUser)
       MERGE (log)-[:RECORDED_ON]->(date)
       MERGE (campusTown)-[:HAS_HISTORY]->(log)
       MERGE (sonta)-[:HAS_HISTORY]->(log)
       MERGE (leader)-[r:HAS_HISTORY]->(log)
        SET r.current = true

      RETURN campusTown
      """
    )
  CreateBacenta(
    bacentaName: String!
    centreId: ID!
    leaderId: ID!
    meetingDay: String!
    venueLongitude: Float
    venueLatitude: Float
  ): Bacenta
    @auth(
      rules: [
        { roles: ["adminFederal", "adminCouncil", "adminCampus", "adminTown"] }
      ]
    )
    @cypher(
      statement: """
      CREATE (bacenta:Bacenta {name:$bacentaName,location: point({latitude:toFloat($venueLatitude), longitude:toFloat($venueLongitude), crs:'WGS-84'})})
         	SET
      	bacenta.id = apoc.create.uuid()

      WITH bacenta
      MATCH (centre:Centre {id: $centreId})
      MATCH (leader:Member {id:$leaderId})
      MATCH (currentUser:Member {auth_id:$auth.jwt.sub})
      MATCH (meetingDay:ServiceDay {day: $meetingDay})

      MERGE (centre)-[:HAS]->(bacenta)
      MERGE (leader)-[r:LEADS]->(bacenta)
      MERGE (bacenta)-[:MEETS_ON]->(meetingDay)
        SET r.current = true

      RETURN bacenta
      """
    )

  #UPDATE OPERATIONS
  UpdateMemberDetails(
    id: ID!
    firstName: String!
    middleName: String
    lastName: String!
    email: String
    phoneNumber: String!
    whatsappNumber: String
    do: String
    maritalStatus: String!
    gender: String!
    occupation: String
    bacenta: String
    ministry: String
    pictureUrl: String!
  ): Member
    @auth(
      rules: [
        {
          roles: [
            "adminFederal"
            "adminCouncil"
            "adminCampus"
            "adminTown"
            "leaderBacenta"
            "leaderCentre"
            "leaderCampus"
            "leaderTown"
          ]
        }
      ]
    )
    @cypher(
      statement: """
      MATCH (member:Member {id:$id})
      SET
      	member.firstName = $firstName,
      	member.middleName = $middleName,
      	member.lastName = $lastName,
      	member.email = $email,
      	member.phoneNumber = $phoneNumber,
        member.whatsappNumber = $whatsappNumber,
      	member.pictureUrl = $pictureUrl

      WITH member

      MATCH (gender:Gender {gender: $gender})
      MERGE (member)-[:HAS_GENDER]-> (gender)


      WITH member
         CALL {
         	WITH member
         	WITH member  WHERE $dob IS NOT NULL
         	MERGE (date:TimeGraph {date: date($dob)})
      	WITH member,date
      	OPTIONAL MATCH (member)-[r1:WAS_BORN_ON]->()
      	DELETE r1
      	MERGE (member)-[:WAS_BORN_ON]->(date)
         	RETURN count(member)
         	}

      WITH member
         CALL {
         	WITH member
         	WITH member  WHERE $maritalStatus IS NOT NULL
         	MATCH (maritalStatus:MaritalStatus {status:$maritalStatus})
      	OPTIONAL MATCH (member)-[r1:HAS_MARITAL_STATUS]->()
      	DELETE r1
      	MERGE (member)-[:HAS_MARITAL_STATUS]-> (maritalStatus)
         	RETURN count(member)
         	}

         WITH member
         CALL {
         	WITH member
         	WITH member  WHERE $occupation IS NOT NULL
      	OPTIONAL MATCH (member)-[r1:HAS_OCCUPATION]-> ()
        MERGE (occupation:Occupation {occupation:$occupation})
      	DELETE r1
      	MERGE (member)-[:HAS_OCCUPATION]-> (occupation)
         	RETURN count(member)
         	}
      WITH member
      CALL {
         	WITH member
         	WITH member  WHERE $bacenta IS NOT NULL
         	MATCH (bacenta:Bacenta {id: $bacenta})
      	OPTIONAL MATCH (member)-[r0:BELONGS_TO]-> (:Bacenta)
      	DELETE r0
      	MERGE (member)-[:BELONGS_TO]-> (bacenta)
         	RETURN count(member)
         	}
      WITH member
      CALL {
         	WITH member
         	WITH member  WHERE $ministry IS NOT NULL
         	MATCH (ministry:Ministry {id:$ministry})
      	OPTIONAL MATCH (member)-[r0:BELONGS_TO]-> (:Ministry)
      	DELETE r0
      	MERGE (member)-[:BELONGS_TO]-> (ministry)
         	RETURN count(member)
         	}

      RETURN member
      """
    )

  UpdateTownDetails(townId: ID!, townName: String!, councilId: ID!): Town
    @auth(rules: [{ roles: ["adminFederal", "adminCouncil"] }])
    @cypher(
      statement: """
      MATCH (town:Town {id: $townId})
      	SET town.name = $townName

      WITH town
         CALL {
         	WITH town
          MATCH (council:Council {id: $councilId})
          OPTIONAL MATCH (town)<-[r:HAS]-()
          DELETE r
          MERGE (council)-[:HAS]->(town)
         	RETURN count(town)
         	}

      MATCH (town)<-[:LEADS]-(leader:Member)
      RETURN town
      """
    )
  UpdateCampusDetails(
    campusId: ID!
    campusName: String!
    councilId: ID!
  ): Campus
    @auth(rules: [{ roles: ["adminFederal", "adminCouncil"] }])
    @cypher(
      statement: """
           MATCH (campus:Campus {id: $campusId})
           	SET campus.name = $campusName

           WITH campus
              CALL {
              	WITH campus

                  MATCH (council:Council {id: $councilId})
                  OPTIONAL MATCH (campus)<-[r:HAS]-()
                  DELETE r
                  MERGE (council)-[:HAS]->(campus)
              	RETURN count(campus)
              	}
      MATCH (campus)<-[:LEADS]-(leader:Member)
      RETURN campus
      """
    )
  UpdateCentreDetails(
    centreId: ID!
    centreName: String!
    campusTownId: ID!
  ): Centre
    @auth(
      rules: [
        { roles: ["adminFederal", "adminCouncil", "adminCampus", "adminTown"] }
      ]
    )
    @cypher(
      statement: """
      MATCH (centre:Centre {id: $centreId})
      	SET centre.name = $centreName

      WITH centre
         CALL {
         	WITH centre
      		OPTIONAL MATCH (campusTown {id: $campusTownId}) WHERE campusTown:Campus OR campusTown:Town

            OPTIONAL MATCH (centre)<-[r:HAS]-()
            DELETE r
            MERGE (campusTown)-[:HAS]->(centre)
         	RETURN count(centre)
         	}
      MATCH (centre)<-[:LEADS]-(leader:Member)
      RETURN centre
      """
    )

  UpdateSontaDetails(sontaId: ID!, sontaName: String!): Sonta
    @auth(
      rules: [
        { roles: ["adminFederal", "adminCouncil", "adminCampus", "adminTown"] }
      ]
    )
    @cypher(
      statement: """
      MATCH (sonta:Sonta {id: $sontaId})
      	SET sonta.name = $sontaName

      WITH sonta
      MATCH (sonta)<-[:LEADS]-(leader:Member)
      RETURN sonta
      """
    )

  UpdateBacentaDetails(
    id: ID!
    name: String!
    meetingDay: String
    venueLongitude: Float
    venueLatitude: Float
  ): Bacenta
    @auth(
      rules: [
        { roles: ["adminFederal", "adminCouncil", "adminCampus", "adminTown"] }
      ]
    )
    @cypher(
      statement: """
               MATCH (bacenta:Bacenta {id: $id})
               	SET bacenta.name = $name
              	SET bacenta.location = point({latitude:toFloat($venueLatitude), longitude:toFloat($venueLongitude), crs:'WGS-84'})

               WITH bacenta
                    CALL {
                     	WITH bacenta
                      WITH bacenta WHERE $meetingDay IS NOT NULL
                      MATCH (meetingDay:ServiceDay {day: $meetingDay})
                      OPTIONAL MATCH (bacenta)-[r:MEETS_ON]->()
                      DELETE r
                      MERGE (bacenta)-[:MEETS_ON]->(meetingDay)
                     	RETURN count(bacenta)
                     	}

      RETURN bacenta
      """
    )
  #DIFFERENT LOG HISTORY MUTATIONS
  ConnectChurchHistory(churchId: ID!): [ServiceLog]
    @cypher(
      statement: """
      MATCH (church {id: $churchId})
      WHERE church:Centre OR church:Town OR church:Campus OR church:Sonta
      MATCH (church)-[r:HAS_HISTORY]->(churchHistory:ServiceLog) WHERE r.current=true
      MATCH (church)-[:HAS]->(downRelatedChurch)
      MATCH (upRelatedChurch)-[:HAS]->(church)
      MATCH (downRelatedChurch)-[r1:HAS_HISTORY]->(downHistory:ServiceLog) WHERE r1.current=true
      MATCH (upRelatedChurch)-[r2:HAS_HISTORY]->(upHistory:ServiceLog) WHERE r2.current=true

      MERGE (upHistory)-[:HAS]->(churchHistory)
      MERGE (churchHistory)-[:HAS]->(downHistory)

      RETURN churchHistory
      """
    )

  ConnectBacentaHistory(churchId: ID!): [ServiceLog]
    @cypher(
      statement: """
      MATCH (church:Bacenta {id: $churchId})
      MATCH (church)-[r:HAS_HISTORY]->(churchHistory:ServiceLog) WHERE r.current=true
      MATCH (upRelatedChurch)-[:HAS]->(church)
      MATCH (upRelatedChurch)-[r2:HAS_HISTORY]->(upHistory:ServiceLog) WHERE r2.current=true

      MERGE (upHistory)-[:HAS]->(churchHistory)

      RETURN churchHistory
      """
    )
  ConnectCouncilHistory(churchId: ID!): [ServiceLog]
    @cypher(
      statement: """
      MATCH (church:Council {id: $churchId})
      MATCH (church)-[r:HAS_HISTORY]-(churchHistory:ServiceLog) WHERE r.current=true
      MATCH (downRelatedChurch)-[:HAS]->(church)
      MATCH (downRelatedChurch)-[r2:HAS_HISTORY]->(downHistory:ServiceLog) WHERE r2.current=true

      MERGE (churchHistory)-[:HAS]->(downHistory)

      RETURN churchHistory
      """
    )

  LogBacentaHistory(
    bacentaId: ID!
    historyRecord: String!
    oldLeaderId: ID
    newLeaderId: ID
    oldCentreId: ID
    newCentreId: ID
  ): Bacenta
    @cypher(
      statement: """
      MATCH  (bacenta:Bacenta {id: $bacentaId})
      MATCH (admin:Member {auth_id: $auth.jwt.sub})
      CREATE (log:HistoryLog {id: apoc.create.uuid()})
        SET log.historyRecord = $historyRecord,
          log.timeStamp = datetime()
      MERGE (date:TimeGraph {date: date()})
      MERGE (bacenta)-[r:HAS_HISTORY]->(log)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (log)-[:LOGGED_BY]->(admin)


      WITH log,bacenta
      CALL{
        WITH log
        WITH log WHERE $oldCentreId IS NOT NULL
        MATCH (oldCentre:Centre {id: $oldCentreId})
        MERGE (oldCentre)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      WITH log,bacenta
      CALL{
        WITH log
        WITH log WHERE $newCentreId IS NOT NULL
        MATCH (newCentre:Centre {id: $newCentreId})
        MERGE (newCentre)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      RETURN bacenta
      """
    )
  LogCentreHistory(
    centreId: ID!
    historyRecord: String!
    newLeaderId: ID
    oldLeaderId: ID
    newCampusTownId: ID
    oldCampusTownId: ID
  ): Centre
    @cypher(
      statement: """
       MATCH  (centre:Centre {id: $centreId})
       MATCH (admin:Member {auth_id: $auth.jwt.sub})
       CREATE (log:HistoryLog {id: apoc.create.uuid()})
         SET log.historyRecord = $historyRecord,
           log.timeStamp = datetime()
       MERGE (date:TimeGraph {date: date()})
       MERGE (centre)-[r:HAS_HISTORY]->(log)
       MERGE (log)-[:RECORDED_ON]->(date)
        MERGE (log)-[:LOGGED_BY]->(admin)

       WITH log,centre
       CALL{
         WITH log
         WITH log WHERE $newLeaderId IS NOT NULL
       MATCH (newLeader:Member {id: $newLeaderId})
      OPTIONAL MATCH (oldLeader:Member {id: $oldLeaderId})
         SET log :ServiceLog
         WITH log, newLeader,oldLeader
       OPTIONAl MATCH (log)<-[r0:HAS_HISTORY]-()
         SET r0.current = false
         WITH log,newLeader,oldLeader
       CREATE (oldLeader)-[:HAS_HISTORY]->(log)
       CREATE (newLeader)-[r:HAS_HISTORY]->(log)
          SET r.current = true
          WITH log
       RETURN COUNT(log)
       }


       WITH log,centre
       CALL {
         WITH log
         WITH log WHERE $oldCampusTownId IS NOT NULL
         MATCH (oldCampusTown {id: $oldCampusTownId}) WHERE oldCampusTown:Town OR oldCampusTown:Campus
         MERGE (oldCampusTown)-[:HAS_HISTORY]->(log)
         RETURN COUNT(log)
       }

       WITH log,centre
       CALL {
         WITH log
         WITH log WHERE $newCampusTownId IS NOT NULL
         MATCH (newCampusTown {id: $newCampusTownId}) WHERE newCampusTown:Town OR newCampusTown:Campus
         MERGE (newCampusTown)-[:HAS_HISTORY]->(log)
         RETURN COUNT(log)
       }

       RETURN centre
      """
    )
  LogCampusTownHistory(
    campusTownId: ID!
    historyRecord: String!
    newLeaderId: ID
    oldLeaderId: ID
    newCouncilId: ID
    oldCouncilId: ID
  ): Constituency
    @cypher(
      statement: """
      MATCH  (campusTown {id: $campusTownId}) WHERE campusTown:Campus OR campusTown:Town
      MATCH (admin:Member {auth_id: $auth.jwt.sub})
      CREATE (log:HistoryLog {id: apoc.create.uuid()})
        SET log.historyRecord = $historyRecord,
          log.timeStamp = datetime()
      MERGE (date:TimeGraph {date: date()})
      MERGE (campusTown)-[r:HAS_HISTORY]->(log)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (log)-[:LOGGED_BY]->(admin)

      WITH log,campusTown
      CALL{
        WITH log
        WITH log WHERE $newLeaderId IS NOT NULL
      MATCH (newLeader:Member {id: $newLeaderId})
        SET log :ServiceLog
        WITH log, newLeader
      OPTIONAl MATCH ()-[r0:HAS_HISTORY]->(log)
        SET r0.current = false
        WITH log,newLeader
      CREATE (newLeader)-[r:HAS_HISTORY]->(log)
         SET r.current = true
         WITH log
      RETURN COUNT(log)
      }

      WITH log,campusTown
      CALL {
        WITH log
        WITH log WHERE $oldLeaderId IS NOT NULL
        MATCH (oldLeader:Member {id: $oldLeaderId})
        CREATE (oldLeader)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }


      WITH log,campusTown
      CALL {
        WITH log
        WITH log WHERE $oldCouncilId IS NOT NULL
        MATCH (council:Council {id: $oldCouncilId})
        MERGE (council)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      WITH log,campusTown
      CALL {
        WITH log
        WITH log WHERE $newCouncilId IS NOT NULL
        MATCH (council:Council {id: $newCouncilId})
        MERGE (council)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      RETURN campusTown
      """
    )

  LogCouncilHistory(
    councilId: ID!
    historyRecord: String!
    newLeaderId: ID
    oldLeaderId: ID
    newGatheringServiceId: ID
    oldGatheringServiceId: ID
  ): Council
    @cypher(
      statement: """
      MATCH  (council:Council {id: $councilId})
      MATCH (admin:Member {auth_id: $auth.jwt.sub})
      CREATE (log:HistoryLog {id: apoc.create.uuid()})
        SET log.historyRecord = $historyRecord,
          log.timeStamp = datetime()
      MERGE (date:TimeGraph {date: date()})
      MERGE (council)-[r:HAS_HISTORY]->(log)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (log)-[:LOGGED_BY]->(admin)

      WITH log,council
      CALL{
        WITH log
        WITH log WHERE $newLeaderId IS NOT NULL
      MATCH (newLeader:Member {id: $newLeaderId})
        SET log :ServiceLog
        WITH log, newLeader
      OPTIONAl MATCH ()-[r0:HAS_HISTORY]->(log)
        SET r0.current = false
        WITH log,newLeader
      CREATE (newLeader)-[r:HAS_HISTORY]->(log)
         SET r.current = true
         WITH log
      RETURN COUNT(log)
      }

      WITH log,council
      CALL {
        WITH log
        WITH log WHERE $oldLeaderId IS NOT NULL
        MATCH (oldLeader:Member {id: $oldLeaderId})
        CREATE (oldLeader)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }


      WITH log,council
      CALL {
        WITH log
        WITH log WHERE $oldGatheringServiceId IS NOT NULL
        MATCH (council:Council {id: $oldGatheringServiceId})
        MERGE (council)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      WITH log,council
      CALL {
        WITH log
        WITH log WHERE $newGatheringServiceId IS NOT NULL
        MATCH (council:Council {id: $newGatheringServiceId})
        MERGE (council)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      RETURN council
      """
    )

  LogSontaHistory(
    sontaId: ID!
    historyRecord: String!
    newLeaderId: ID
    oldLeaderId: ID
  ): Sonta
    @cypher(
      statement: """
       MATCH  (sonta:Sonta {id: $sontaId})
       MATCH (admin:Member {auth_id: $auth.jwt.sub})
       CREATE (log:HistoryLog {id: apoc.create.uuid()})
         SET log.historyRecord = $historyRecord,
           log.timeStamp = datetime()
       MERGE (date:TimeGraph {date: date()})
       MERGE (sonta)-[r:HAS_HISTORY]->(log)
       MERGE (log)-[:RECORDED_ON]->(date)
       MERGE (log)-[:LOGGED_BY]->(admin)

       WITH log,sonta
       CALL{
         WITH log
         WITH log WHERE $newLeaderId IS NOT NULL
       MATCH (newLeader:Member {id: $newLeaderId})
      OPTIONAL MATCH (oldLeader:Member {id: $oldLeaderId})
         SET log :ServiceLog
         WITH log, newLeader,oldLeader
       OPTIONAl MATCH ()-[r0:HAS_HISTORY]->(log)
         SET r0.current = false
         WITH log,newLeader,oldLeader
       CREATE (oldLeader)-[:HAS_HISTORY]->(log)
       CREATE (newLeader)-[r:HAS_HISTORY]->(log)
          SET r.current = true
          WITH log
       RETURN COUNT(log)
       }


       RETURN sonta
      """
    )

  #SERVICE RECORDS MUTATIONS
  RecordService(
    id: ID!
    serviceDate: String!
    attendance: Int!
    income: Float!
    foreignCurrency: String
    numberOfTithers: Int
    treasurers: [ID]!
    treasurerSelfie: String!
    servicePicture: String!
  ): ServiceRecord
    @cypher(
      statement: """
      CREATE (serviceRecord:ServiceRecord {created_at:datetime()})
        SET serviceRecord.id = apoc.create.uuid(),
        serviceRecord.attendance = $attendance,
        serviceRecord.income = $income,
        serviceRecord.foreignCurrency = $foreignCurrency,
        serviceRecord.numberOfTithers = $numberOfTithers,
        serviceRecord.treasurerSelfie = $treasurerSelfie,
        serviceRecord.servicePicture = $servicePicture
      WITH serviceRecord
      MATCH (church {id:$id}) WHERE church:Bacenta OR church:Centre OR church:Campus OR church:Town
      MATCH (church)-[has_history:HAS_HISTORY]->(log:HistoryLog) WHERE has_history.current = true
      MATCH (leader:Member {auth_id: $auth.jwt.sub})

      MERGE (serviceRecord)-[:LOGGED_BY]->(leader)
      MERGE (serviceDate:TimeGraph {date:date($serviceDate)})
      MERGE (serviceRecord)-[:SERVICE_HELD_ON]->(serviceDate)
      MERGE (log)-[:HAS_RECORD]->(serviceRecord)

      WITH serviceRecord
      UNWIND $treasurers AS treasurerId WITH treasurerId, serviceRecord
      MATCH (treasurer:Member {id: treasurerId})
      MERGE (treasurer)-[:WAS_TREASURER_FOR]->(serviceRecord)

      RETURN serviceRecord
      """
    )

  RecordCancelledService(
    id: ID!
    serviceDate: String!
    noServiceReason: String!
  ): NoService
    @cypher(
      statement: """
      CREATE (serviceRecord:ServiceRecord:NoService {created_at:datetime()})
        SET serviceRecord.id = apoc.create.uuid(),
        serviceRecord.noServiceReason = $noServiceReason

      WITH serviceRecord
      MATCH (church {id:$id}) WHERE church:Bacenta OR church:Centre OR church:Campus OR church:Town
      MATCH (church)-[has_history:HAS_HISTORY]->(log:HistoryLog) WHERE has_history.current = true
      MATCH (leader:Member {auth_id: $auth.jwt.sub})

      MERGE (serviceRecord)-[:LOGGED_BY]->(leader)
      MERGE (serviceDate:TimeGraph {date:date($serviceDate)})
      MERGE (serviceRecord)-[:SERVICE_HELD_ON]->(serviceDate)
      MERGE (log)-[:HAS_RECORD]->(serviceRecord)

      RETURN serviceRecord
      """
    )

  RecordServiceNoOffering(
    id: ID!
    serviceDate: String!
    attendance: Int!
    servicePicture: String!
  ): ServiceRecord
    @cypher(
      statement: """
      CREATE (serviceRecord:ServiceRecord {created_at:datetime()})
        SET serviceRecord.id = apoc.create.uuid(),
        serviceRecord.attendance = $attendance,
        serviceRecord.servicePicture = $servicePicture
      WITH serviceRecord
      MATCH (church {id:$id}) WHERE church:Bacenta OR church:Centre OR church:Sonta OR church:Campus OR church:Town
      MATCH (church)-[has_history:HAS_HISTORY]->(log:HistoryLog) WHERE has_history.current = true
      MATCH (leader:Member {auth_id: $auth.jwt.sub})

      MERGE (serviceRecord)-[:LOGGED_BY]->(leader)
      MERGE (serviceDate:TimeGraph {date:date($serviceDate)})
      MERGE (serviceRecord)-[:SERVICE_HELD_ON]->(serviceDate)
      MERGE (log)-[:HAS_RECORD]->(serviceRecord)

      RETURN serviceRecord
      """
    )

  #Set Bacenta to be 'OnVacation
  SetBacentaOnVacation(bacentaId: ID!): Bacenta
    @cypher(
      statement: """
      MATCH (bacenta:Bacenta {id:$bacentaId})
      OPTIONAL MATCH (bacenta)-[:HAS]-(centre)
      MATCH (admin:Member {auth_id: $auth.jwt.sub})

      CREATE (log:HistoryLog {id:apoc.create.uuid()})
        SET log.timeStamp = datetime(),
        log.historyRecord = bacenta.name + ' Bacenta was closed down under ' + centre.name +' Centre'


      MERGE (date:TimeGraph {date:date()})
      MERGE (log)-[:LOGGED_BY]->(admin)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (bacenta)-[:HAS_HISTORY]->(log)
      MERGE (centre)-[:HAS_HISTORY]->(log)

      SET bacenta:ClosedBacenta
      REMOVE bacenta:Bacenta

      RETURN bacenta
      """
    )

  #DELETE OPERATIONS
  # In the context of church data we never delete, we only render inactive
  CloseDownBacenta(bacentaId: ID!): Bacenta
  CloseDownCentre(centreId: ID!): Centre
    @cypher(
      statement: """
      MATCH (centre:Centre {id:$centreId})
      MATCH (admin:Member {auth_id: $auth.jwt.sub})
      OPTIONAL MATCH (centre)-[:HAS]-(campusTown)
      OPTIONAL MATCH (centre)-[:HAS]->(bacentas)
      UNWIND labels(campusTown) AS stream

      CREATE (log:HistoryLog {id:apoc.create.uuid()})
        SET log.timeStamp = datetime(),
        log.historyRecord = centre.name + ' Centre was closed down under ' + campusTown.name +' '+stream


      MERGE (date:TimeGraph {date:date()})
      MERGE (log)-[:LOGGED_BY]->(admin)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (centre)-[:HAS_HISTORY]->(log)
      MERGE (campusTown)-[:HAS_HISTORY]->(log)

      SET centre:ClosedCentre, bacentas:ClosedBacenta
      REMOVE centre:Centre,  bacentas:Bacenta


      RETURN centre
      """
    )

  CloseDownCampusTown(campusTownId: ID!): Constituency
    @cypher(
      statement: """
      MATCH (campusTown {id:$campusTownId}) WHERE campusTown:Campus OR campusTown:Town
      MATCH (admin:Member {auth_id: $auth.jwt.sub})
      MATCH (campusTown)-[:HAS]-(council:Council)
      OPTIONAL MATCH (campusTown)-[:HAS]->(centres)-[:HAS]->(bacentas)
      UNWIND labels(campusTown) AS stream

      CREATE (log:HistoryLog {id:apoc.create.uuid()})
        SET log.timeStamp = datetime(),
        log.historyRecord = campusTown.name + ' '+stream +' was closed down under ' + council.name +' Council'


      MERGE (date:TimeGraph {date:date()})
      MERGE (log)-[:LOGGED_BY]->(admin)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (council)-[:HAS_HISTORY]->(log)
      MERGE (bishop)-[:HAS_HISTORY]->(log)

      SET campusTown:ClosedCampusTown, centres:ClosedCentre, bacentas:ClosedBacenta
      REMOVE campusTown:Campus:Town,centres:Centre,bacentas:Bacenta

      RETURN campusTown
      """
    )

  #CHURCH CONVERSIONS
  MakeBacentaIntoCentre(bacentaId: ID!): Centre
    @cypher(
      statement: """
      MATCH (bacenta:Bacenta {id:$bacentaId})
      MATCH (admin:Member {auth_id: $auth.jwt.sub})
      CREATE (newBacenta:Bacenta {id:apoc.create.uuid()})
       SET newBacenta.name = bacenta.name,
       newBacenta.location = bacenta.location
      CREATE (log:HistoryLog {id:apoc.create.uuid()})
        SET log.timeStamp = datetime(),
        log.historyRecord = bacenta.name + ' was made into a Centre with '+ newBacenta.name+' as a bacenta under it.'

      WITH newBacenta, log, bacenta
      MATCH (bacenta)<-[hasBacenta:HAS]-(:Centre)<-[:HAS]-(campusTown)
      MATCH (bacenta)-[meetsOnDay:MEETS_ON]->(meetingDay)
      MATCH (bacenta)<-[belongsTo:BELONGS_TO]-(member:Member)
      MATCH (bacenta)<-[:LEADS]-(leader:Member)

      MERGE (date:TimeGraph {date:date()})
      MERGE (campusTown)-[:HAS]->(bacenta)
      MERGE (newBacenta)-[:MEETS_ON]->(meetingDay)
      MERGE (newBacenta)<-[:LEADS]-(leader)
      MERGE (member)-[:BELONGS_TO]->(newBacenta)
      MERGE (bacenta)-[:HAS]->(newBacenta)

      DELETE hasBacenta,meetsOnDay,belongsTo

      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (log)-[:LOGGED_BY]->(admin)
      MERGE (bacenta)-[:HAS_HISTORY]->(log)
      MERGE (newBacenta)-[:HAS_HISTORY]->(log)

      SET bacenta:Centre
      REMOVE bacenta.location
      REMOVE bacenta:Bacenta
      RETURN bacenta
      """
    )
}
