type Member {
  id: ID!
  auth_id: String
  firstName: String #@search
  middleName: String
  lastName: String
  fullName: String @ignore
  email: String
  phoneNumber: String
  whatsappNumber: String
  pictureUrl: String
  gender: Gender @relationship(type: "HAS_GENDER", direction: OUT)
  maritalStatus: MaritalStatus
    @relationship(type: "HAS_MARITAL_STATUS", direction: OUT)
  dob: TimeGraph @relationship(type: "WAS_BORN_ON", direction: OUT)
  title: [Title]
    @relationship(type: "HAS_TITLE", properties: "HasTitle", direction: OUT)
  ministry: Ministry @relationship(type: "BELONGS_TO", direction: OUT)
  occupation: Occupation @relationship(type: "HAS_OCCUPATION", direction: OUT)
  stream: String
    @cypher(
      statement: """
      MATCH (this)-[:BELONGS_TO]->(:Fellowship)<-[:HAS*4]-(stream:Stream)
      RETURN DISTINCT toLower(stream.name)
      """
    )
  # Church Details
  members: [Member]
    @cypher(
      statement: """
      MATCH (this)-[:LEADS|HAS|IS_ADMIN_FOR*1..4]->(:Fellowship)-[:BELONGS_TO]-(members)
      RETURN DISTINCT members
      """
    )
  memberCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:LEADS|HAS|IS_ADMIN_FOR*1..4]->(:Fellowship)-[:BELONGS_TO]-(members)
      RETURN COUNT(DISTINCT members)
      """
    )
  basontaMembers: [Member]
    @cypher(
      statement: """
      MATCH (this)-[:LEADS|HAS|IS_ADMIN_FOR*1..4]->(:Fellowship)-[:BELONGS_TO]-(members)
      MATCH (members)-[:BELONGS_TO]->(:Ministry)
      RETURN DISTINCT members
      """
    )
  basontaMembershipCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:LEADS|HAS|IS_ADMIN_FOR*1..4]->(:Fellowship)-[:BELONGS_TO]-(members)
      MATCH (members)-[:BELONGS_TO]->(:Ministry)
      RETURN COUNT(DISTINCT members)
      """
    )
  history: [HistoryLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  loggedHistory: [HistoryLog] @relationship(type: "LOGGED_BY", direction: IN)
  fellowship: Fellowship @relationship(type: "BELONGS_TO", direction: OUT)
  leadsFellowship: [Fellowship] @relationship(type: "LEADS", direction: OUT)
  leadsFellowshipCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:LEADS]->(fellowships:Fellowship)
      RETURN COUNT(fellowships)
      """
    )
  leadsBacenta: [Bacenta] @relationship(type: "LEADS", direction: OUT)
  leadsBacentaCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:LEADS]->(bacentas:Bacenta)
      RETURN COUNT(bacentas)
      """
    )
  leadsMinistry: [Ministry] @relationship(type: "LEADS", direction: OUT)
  leadsSonta: [Sonta] @relationship(type: "LEADS", direction: OUT)
  leadsBasonta: [Basonta] @relationship(type: "LEADS", direction: OUT)
  leadsTown: [Town] @relationship(type: "LEADS", direction: OUT)
  leadsCampus: [Campus] @relationship(type: "LEADS", direction: OUT)
  leadsConstituencyCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:LEADS|IS_ADMIN_FOR]->(constituency) WHERE constituency:Campus OR constituency:Town
      RETURN COUNT(DISTINCT constituency)
      """
    )
  leadsCouncil: [Council] @relationship(type: "LEADS", direction: OUT)
  leadsCouncilCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:LEADS|HAS|IS_ADMIN_FOR]->(council:Council)
      RETURN COUNT(DISTINCT council)
      """
    )
  isAdminForCouncil: [Council]
    @relationship(type: "IS_ADMIN_FOR", direction: OUT) #@neo4j_ignore
  isAdminForCampus: [Campus] @relationship(type: "IS_ADMIN_FOR", direction: OUT)
  isAdminForTown: [Town] @relationship(type: "IS_ADMIN_FOR", direction: OUT)

  #OTHER WORKS
  was_treasurer_for: [ServiceRecord]!
    @relationship(type: "WAS_TREASURER_FOR", direction: OUT)
}

# extend type Member @auth(rules: [{ isAuthenticated: true }])
# extend type Fellowship @auth(rules: [{ isAuthenticated: true }])
# extend type Bacenta @auth(rules: [{ isAuthenticated: true }])
# extend type Campus @auth(rules: [{ isAuthenticated: true }])
# extend type Town @auth(rules: [{ isAuthenticated: true }])
# extend type Council @auth(rules: [{ isAuthenticated: true }])
# extend type Sonta @auth(rules: [{ isAuthenticated: true }])
# extend type Ministry @auth(rules: [{ isAuthenticated: true }])

type Gender @auth(rules: [{ isAuthenticated: true }]) {
  gender: String
  members: [Member] @relationship(type: "HAS_GENDER", direction: IN)
}

type MaritalStatus @auth(rules: [{ isAuthenticated: true }]) {
  status: String
  members: [Member] @relationship(type: "HAS_MARITAL_STATUS", direction: IN)
}

type Occupation @auth(rules: [{ isAuthenticated: true }]) {
  occupation: String
  members: [Member] @relationship(type: "HAS_OCCUPATION", direction: IN)
}

type Title @auth(rules: [{ isAuthenticated: true }]) {
  title: String! #Pastor, Reverend, Apostle, Bishop (Mother)
  members: [Member]
    @relationship(type: "HAS_TITLE", properties: "HasTitle", direction: IN)
}

interface HasTitle @relationshipProperties {
  dateAppointed: Date
}

type TimeGraph @auth(rules: [{ isAuthenticated: true }]) {
  date: Date
  memberDo: Member @relationship(type: "WAS_BORN_ON", direction: IN)
  # titleAppointmentDate: Member @relationship(type: "APPOINTED_ON", direction: IN)
  leaderHistoryStartDate: Member
    @relationship(type: "LEADER_STARTED_ON", direction: OUT)
  leaderHistoryEndDate: TimeGraph
    @relationship(type: "LEADER_ENDED_ON", direction: OUT)
  historyDate: Member @relationship(type: "RECORDED_ON", direction: OUT)
  serviceDate: [ServiceRecord]
    @relationship(type: "SERVICE_HELD_ON", direction: IN)
}

type ServiceRecord @auth(rules: [{ isAuthenticated: true }]) {
  id: ID!
  created_at: Date
  created_by: Member @relationship(type: "LOGGED_BY", direction: OUT)
  serviceDate: TimeGraph @relationship(type: "SERVICE_HELD_ON", direction: OUT)
  week: Int
    @cypher(
      statement: """
      MATCH (this)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      RETURN date(date.date).week
      """
    )
  attendance: Int
  income: Float
  foreignCurrency: String
  servicePicture: String
  treasurerSelfie: String
  bankingSlip: String
  treasurers: [Member]! @relationship(type: "WAS_TREASURER_FOR", direction: IN)
  serviceLog: ServiceLog @relationship(type: "HAS_RECORD", direction: IN)
  noServiceReason: String
}

type NoService @auth(rules: [{ isAuthenticated: true }]) {
  id: ID!
  created_at: Date
  created_by: Member @relationship(type: "LOGGED_BY", direction: OUT)
  serviceDate: TimeGraph @relationship(type: "SERVICE_HELD_ON", direction: OUT)
  week: Int
    @cypher(
      statement: """
      MATCH (this)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      RETURN date(date.date).week
      """
    )
  serviceLog: ServiceLog @relationship(type: "HAS_RECORD", direction: IN)
  noServiceReason: String
}

type ServiceLog @auth(rules: [{ isAuthenticated: true }]) {
  id: ID
  historyRecord: String #leader was transferred to
  created_at: TimeGraph @relationship(type: "RECORDED_ON", direction: OUT)
  loggedBy: Member @relationship(type: "LOGGED_BY", direction: OUT)
  serviceRecords: [ServiceRecord]
    @relationship(type: "HAS_RECORD", direction: OUT)
  leaders: [Member] @relationship(type: "HAS_HISTORY", direction: IN)
  fellowship: [Fellowship] @relationship(type: "HAS_HISTORY", direction: IN)
  bacenta: [Bacenta] @relationship(type: "HAS_HISTORY", direction: IN)
  # bacentaFellowshipRecords(bacentaId: ID!): [BacentaFellowshipServiceRecords]
  campus: [Campus] @relationship(type: "HAS_HISTORY", direction: IN)
  town: [Town] @relationship(type: "HAS_HISTORY", direction: IN)
  sonta: [Sonta] @relationship(type: "HAS_HISTORY", direction: IN)
}

type ComponentServiceAggregate {
  week: Int!
  attendance: Int!
  income: Float!
}

type HistoryLog @auth(rules: [{ isAuthenticated: true }]) {
  id: ID @id
  timeStamp: DateTime
  historyRecord: String #leader was transferred to
  created_at: TimeGraph @relationship(type: "RECORDED_ON", direction: OUT)
  loggedBy: Member @relationship(type: "LOGGED_BY", direction: OUT)
  leaders: [Member] @relationship(type: "HAS_HISTORY", direction: IN)
  fellowship: [Fellowship] @relationship(type: "HAS_HISTORY", direction: IN)
  bacenta: [Bacenta] @relationship(type: "HAS_HISTORY", direction: IN)
  campus: [Campus] @relationship(type: "HAS_HISTORY", direction: IN)
  town: [Town] @relationship(type: "HAS_HISTORY", direction: IN)
  sonta: [Sonta] @relationship(type: "HAS_HISTORY", direction: IN)
}

# Campus-Bacenta, Town-Bacenta
type Constituency {
  id: ID @id
  name: String
  stream: String
    @cypher(
      statement: """
      MATCH (this)<-[:HAS*2]-(stream:Stream)
      RETURN DISTINCT toLower(stream.name)
      """
    )
  members: [Member]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowship:Fellowship)<-[:BELONGS_TO]-(members:Member)
      RETURN DISTINCT members
      """
    )
  memberCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowship:Fellowship)<-[:BELONGS_TO]-(members:Member)
      RETURN COUNT(DISTINCT members)
      """
    )
  fellowshipCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS]-(:Bacenta)-[:HAS]->(fellowship:Fellowship) RETURN COUNT(fellowship)"
    )
  activeFellowshipCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS]-(:Bacenta)-[:HAS]->(fellowship:ActiveFellowship) RETURN COUNT(fellowship)"
    )
  leader: Member @relationship(type: "LEADS", direction: IN)
  sontas: [Sonta] @relationship(type: "HAS_SONTA", direction: OUT)
  bacentas: [Bacenta] @relationship(type: "HAS", direction: OUT)
  council: Council @relationship(type: "HAS", direction: IN)
  bishop: Member
    @cypher(
      statement: "MATCH (this)-[:HAS]-(:Council)-[:LEADS]-(bishop:Member) RETURN bishop"
    )
  admin: Member @relationship(type: "IS_ADMIN_FOR", direction: IN)
  history: [HistoryLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  serviceRecord: [ServiceRecord]
    @relationship(type: "HAS_RECORD", direction: OUT)
  serviceLogs: [ServiceLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  services(limit: Int!): [ServiceRecord]
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(records:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      RETURN records ORDER BY date.date LIMIT $limit
      """
    )
  servicesThisWeek: [Fellowship]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowships:ActiveFellowship)
      WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week
        }
      RETURN fellowships
      """
    )
  servicesThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowships:ActiveFellowship)
      WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week
        }
      RETURN COUNT(fellowships)
      """
    )
  cancelledServicesThisWeek: [Fellowship]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowships:ActiveFellowship)
      WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week AND record.noServiceReason IS NOT NULL
        }
      RETURN fellowships
      """
    )
  cancelledServicesThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowships:ActiveFellowship)
      WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week AND record.noServiceReason IS NOT NULL
        }
      RETURN COUNT(fellowships)
      """
    )
  formDefaultersThisWeek: [Fellowship]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowships:ActiveFellowship)
      WHERE EXISTS {
        MATCH (fellowships)-[:MEETS_ON]->(day:ServiceDay)
        WHERE day.dayNumber < date().dayOfWeek OR  time() > time('20:30')
         }
         MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week <> date().week
      RETURN fellowships
      """
    )
  formDefaultersThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowships:ActiveFellowship)
           WHERE EXISTS {
             MATCH (fellowships)-[:MEETS_ON]->(day:ServiceDay)
             WHERE day.dayNumber < date().dayOfWeek OR  time() > time('20:30')
              }
              MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week <> date().week
      RETURN COUNT(fellowships)
      """
    )
  bankingDefaultersThisWeek: [Fellowship]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowships) WHERE fellowships:ActiveFellowship OR fellowships:ClosedFellowship
      MATCH (fellowships) WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week AND record.noServiceReason IS NULL AND record.bankingSlip IS NULL
        }
      RETURN fellowships
      """
    )
  bankingDefaultersThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowships) WHERE fellowships:ActiveFellowship OR fellowships:ClosedFellowship
      MATCH (fellowships) WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week AND record.noServiceReason IS NULL AND record.bankingSlip IS NULL
        }
      RETURN COUNT(fellowships)
      """
    )
  bankedThisWeek: [Fellowship]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowships) WHERE fellowships:ActiveFellowship OR fellowships:ClosedFellowship
      MATCH (fellowships) WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week AND record.noServiceReason IS NULL AND record.bankingSlip IS NOT NULL
        }
      RETURN fellowships
      """
    )
  bankedThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowships) WHERE fellowships:ActiveFellowship OR fellowships:ClosedFellowship
      MATCH (fellowships) WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week AND record.noServiceReason IS NULL AND record.bankingSlip IS NOT NULL
        }
      RETURN COUNT(fellowships)
      """
    )

  componentServiceAggregate: [ComponentServiceAggregate] @ignore
}

type GatheringService {
  id: ID @id
  name: String!
  leader: Member @relationship(type: "LEADS", direction: IN)
  councils: [Council] @relationship(type: "HAS", direction: OUT)
  members: [Member]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*5]->(:Fellowship)<-[:BELONGS_TO]-(members:Member)
      RETURN DISTINCT members
      """
    )
  memberCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*5]->(:Fellowship)<-[:BELONGS_TO]-(members:Member)
      RETURN COUNT(DISTINCT members)
      """
    )
  admin: Member @relationship(type: "IS_ADMIN_FOR", direction: IN)
  services(limit: Int!): [ServiceRecord]
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(services:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      RETURN services ORDER BY date.date LIMIT $limit
      """
    )
}

type Stream {
  id: ID @id
  name: String!
  leader: Member @relationship(type: "LEADS", direction: IN)
  councils: [Council] @relationship(type: "HAS", direction: OUT)
  towns: [Town]
    @cypher(statement: "MATCH (this)-[:HAS*2]->(towns:Town) RETURN towns")
  campuses: [Campus]
    @cypher(
      statement: "MATCH (this)-[:HAS*2]->(campuses:Campus) RETURN campuses"
    )
  bacentas: [Bacenta]
    @cypher(
      statement: "MATCH (this)-[:HAS*3]->(bacenta:Bacenta) RETURN bacenta"
    )
  constituencies: [Constituency]
    @cypher(
      statement: "MATCH (this)-[:HAS*3]->(constituencies:Constituency) RETURN constituencies"
    )
  members: [Member]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*5]->(:Fellowship)<-[:BELONGS_TO]-(members:Member)
      RETURN DISTINCT members
      """
    )
  memberCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*5]->(:Fellowship)<-[:BELONGS_TO]-(members:Member)
      RETURN COUNT(DISTINCT members)
      """
    )
  pastorCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*5]->(:Fellowship)<-[:BELONGS_TO]-(pastors:Member)-[:HAS_TITLE]->(:Title)
      RETURN COUNT(DISTINCT pastors)
      """
    )
  constituencyCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*2]->(constituency) WHERE constituency:Campus OR constituency:Town RETURN COUNT(constituency)"
    )
  bacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*3]->(bacentas:Bacenta) RETURN COUNT(DISTINCT bacentas)"
    )
  fellowshipCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*4]->(fellowships:Fellowship) RETURN COUNT(DISTINCT fellowships)"
    )
  admin: Member @relationship(type: "IS_ADMIN_FOR", direction: IN)
  history: [HistoryLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  serviceRecord: [ServiceRecord]
    @relationship(type: "HAS_RECORD", direction: OUT)
  serviceLogs: [ServiceLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  services(limit: Int!): [ServiceRecord]
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(services:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      RETURN services ORDER BY date.date LIMIT $limit
      """
    )
  componentServiceAggregate: [ComponentServiceAggregate] @ignore
}

type Council {
  id: ID @id
  name: String!
  leader: Member @relationship(type: "LEADS", direction: IN)
  stream: String
    @cypher(
      statement: """
      MATCH (this)<-[:HAS]-(stream:Stream)
      RETURN DISTINCT toLower(stream.name)
      """
    )
  towns: [Town] @relationship(type: "HAS", direction: OUT)
  campuses: [Campus] @relationship(type: "HAS", direction: OUT)
  bacentas: [Bacenta]
    @cypher(
      statement: "MATCH (this)-[:HAS*1..2]->(bacenta:Bacenta) RETURN bacenta"
    )
  constituencies: [Constituency] @relationship(type: "HAS", direction: OUT)
  members: [Member]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(:Fellowship)<-[:BELONGS_TO]-(members:Member)
      RETURN DISTINCT members
      """
    )
  memberCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(:Fellowship)<-[:BELONGS_TO]-(members:Member)
      RETURN COUNT(DISTINCT members)
      """
    )
  pastorCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(:Fellowship)<-[:BELONGS_TO]-(pastors:Member)-[:HAS_TITLE]->(:Title)
      RETURN COUNT(DISTINCT pastors)
      """
    )
  constituencyCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS]->(constituency) WHERE constituency:Campus OR constituency:Town RETURN COUNT(constituency)"
    )
  bacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*2]->(bacentas:Bacenta) RETURN COUNT(DISTINCT bacentas)"
    )
  fellowshipCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*3]->(fellowships:Fellowship) RETURN COUNT(DISTINCT fellowships)"
    )
  activeFellowshipCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*3]->(fellowships:ActiveFellowship) RETURN COUNT(DISTINCT fellowships)"
    )
  admin: Member @relationship(type: "IS_ADMIN_FOR", direction: IN)
  history: [HistoryLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  serviceRecord: [ServiceRecord]
    @relationship(type: "HAS_RECORD", direction: OUT)
  serviceLogs: [ServiceLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  services(limit: Int!): [ServiceRecord]
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(services:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      RETURN services ORDER BY date.date LIMIT $limit
      """
    )
  servicesThisWeek: [Fellowship]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(fellowships:ActiveFellowship)
      WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week
        }
      RETURN fellowships
      """
    )
  servicesThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(fellowships:ActiveFellowship)
      WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week
        }
      RETURN COUNT(DISTINCT fellowships)
      """
    )
  cancelledServicesThisWeek: [Fellowship]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(fellowships:ActiveFellowship)
      WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week AND record.noServiceReason IS NOT NULL
        }
      RETURN fellowships
      """
    )
  cancelledServicesThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(fellowships:ActiveFellowship)
      WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week AND record.noServiceReason IS NOT NULL AND record.attendance IS NULL
        }
      RETURN COUNT(fellowships)
      """
    )
  formDefaultersThisWeek: [Fellowship]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(fellowships:ActiveFellowship)
      WHERE EXISTS {
             MATCH (fellowships)-[:MEETS_ON]->(day:ServiceDay)
             WHERE day.dayNumber < date().dayOfWeek OR  time() > time('20:30')
              }
              MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week <> date().week
      RETURN fellowships
      """
    )
  formDefaultersThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(fellowships:ActiveFellowship)
      WHERE EXISTS {
             MATCH (fellowships)-[:MEETS_ON]->(day:ServiceDay)
             WHERE day.dayNumber < date().dayOfWeek OR  time() > time('20:30')
              }
              MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week <> date().week
      RETURN COUNT(fellowships)
      """
    )
  bankingDefaultersThisWeek: [Fellowship]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(fellowships) WHERE fellowships:ActiveFellowship OR fellowships:ClosedFellowship
      MATCH (fellowships) WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week AND record.noServiceReason IS NULL AND record.bankingSlip IS NULL
        }
      RETURN fellowships
      """
    )
  bankingDefaultersThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(fellowships) WHERE fellowships:ActiveFellowship OR fellowships:ClosedFellowship
      MATCH (fellowships) WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week AND record.noServiceReason IS NULL AND record.bankingSlip IS NULL
        }
      RETURN COUNT(fellowships)
      """
    )
  bankedThisWeek: [Fellowship]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(fellowships) WHERE fellowships:ActiveFellowship OR fellowships:ClosedFellowship
      MATCH (fellowships) WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week AND record.noServiceReason IS NULL AND record.bankingSlip IS NOT NULL
        }
      RETURN fellowships
      """
    )
  bankedThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(fellowships) WHERE fellowships:ActiveFellowship OR fellowships:ClosedFellowship
      MATCH (fellowships) WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week AND record.noServiceReason IS NULL AND record.bankingSlip IS NOT NULL
        }
      RETURN COUNT(fellowships)
      """
    )

  componentServiceAggregate: [ComponentServiceAggregate] @ignore
}

type Campus {
  id: ID @id
  name: String
  stream: String
    @cypher(
      statement: """
      MATCH (this)<-[:HAS*2]-(stream:Stream)
      RETURN DISTINCT toLower(stream.name)
      """
    )
  members: [Member]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowship:Fellowship)<-[:BELONGS_TO]-(members:Member)
      RETURN DISTINCT members
      """
    )
  memberCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowship:Fellowship)<-[:BELONGS_TO]-(members:Member)
      RETURN COUNT(DISTINCT members)
      """
    )
  fellowshipCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS]-(:Bacenta)-[:HAS]->(fellowship:Fellowship) RETURN COUNT(fellowship)"
    )
  activeFellowshipCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS]-(:Bacenta)-[:HAS]->(fellowship:ActiveFellowship) RETURN COUNT(fellowship)"
    )
  leader: Member @relationship(type: "LEADS", direction: IN)
  sontas: [Sonta] @relationship(type: "HAS_SONTA", direction: OUT)
  bacentas: [Bacenta] @relationship(type: "HAS", direction: OUT)
  council: Council @relationship(type: "HAS", direction: IN)
  bishop: Member
    @cypher(
      statement: "MATCH (this)-[:HAS]-(:Council)-[:LEADS]-(bishop:Member) RETURN bishop"
    )
  admin: Member @relationship(type: "IS_ADMIN_FOR", direction: IN)
  history: [HistoryLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  serviceRecord: [ServiceRecord]
    @relationship(type: "HAS_RECORD", direction: OUT)
  serviceLogs: [ServiceLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  services(limit: Int!): [ServiceRecord]
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(records:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      RETURN records ORDER BY date.date LIMIT $limit
      """
    )
  servicesThisWeek: [Fellowship]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowships:ActiveFellowship)
      WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week
        }
      RETURN fellowships
      """
    )
  servicesThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowships:ActiveFellowship)
      WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week
        }
      RETURN COUNT(fellowships)
      """
    )
  cancelledServicesThisWeek: [Fellowship]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowships:ActiveFellowship)
      WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week AND record.noServiceReason IS NOT NULL
        }
      RETURN fellowships
      """
    )
  cancelledServicesThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowships:ActiveFellowship)
      WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week AND record.noServiceReason IS NOT NULL
        }
      RETURN COUNT(fellowships)
      """
    )
  formDefaultersThisWeek: [Fellowship]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowships:ActiveFellowship)
      WHERE EXISTS {
             MATCH (fellowships)-[:MEETS_ON]->(day:ServiceDay)
             WHERE day.dayNumber < date().dayOfWeek OR  time() > time('20:30')
              }
              MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week <> date().week
      RETURN fellowships
      """
    )
  formDefaultersThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowships:ActiveFellowship)
      WHERE EXISTS {
             MATCH (fellowships)-[:MEETS_ON]->(day:ServiceDay)
             WHERE day.dayNumber < date().dayOfWeek OR  time() > time('20:30')
              }
              MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week <> date().week
      RETURN COUNT(fellowships)
      """
    )
  bankingDefaultersThisWeek: [Fellowship]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowships) WHERE fellowships:ActiveFellowship OR fellowships:ClosedFellowship
      MATCH (fellowships) WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week AND record.noServiceReason IS NULL AND record.bankingSlip IS NULL
        }
      RETURN fellowships
      """
    )
  bankingDefaultersThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowships) WHERE fellowships:ActiveFellowship OR fellowships:ClosedFellowship
      MATCH (fellowships) WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week AND record.noServiceReason IS NULL AND record.bankingSlip IS NULL
        }
      RETURN COUNT(fellowships)
      """
    )
  bankedThisWeek: [Fellowship]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowships) WHERE fellowships:ActiveFellowship OR fellowships:ClosedFellowship
      MATCH (fellowships) WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week AND record.noServiceReason IS NULL AND record.bankingSlip IS NOT NULL
        }
      RETURN fellowships
      """
    )
  bankedThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowships) WHERE fellowships:ActiveFellowship OR fellowships:ClosedFellowship
      MATCH (fellowships) WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week AND record.noServiceReason IS NULL AND record.bankingSlip IS NOT NULL
        }
      RETURN COUNT(fellowships)
      """
    )

  componentServiceAggregate: [ComponentServiceAggregate] @ignore
}

type Town {
  id: ID @id
  name: String
  stream: String
    @cypher(
      statement: """
      MATCH (this)<-[:HAS*2]-(stream:Stream)
      RETURN DISTINCT toLower(stream.name)
      """
    )

  members: [Member]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowship:Fellowship)<-[:BELONGS_TO]-(members:Member)
      RETURN DISTINCT members
      """
    )
  memberCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowship:Fellowship)<-[:BELONGS_TO]-(members:Member)
      RETURN COUNT(DISTINCT members)
      """
    )
  fellowshipCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS]-(:Bacenta)-[:HAS]->(fellowship:Fellowship) RETURN COUNT(fellowship)"
    )
  activeFellowshipCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS]-(:Bacenta)-[:HAS]->(fellowship:ActiveFellowship) RETURN COUNT(fellowship)"
    )
  leader: Member @relationship(type: "LEADS", direction: IN)
  sontas: [Sonta] @relationship(type: "HAS_SONTA", direction: OUT)
  bacentas: [Bacenta] @relationship(type: "HAS", direction: OUT)
  council: Council @relationship(type: "HAS", direction: IN)
  bishop: Member
    @cypher(
      statement: "MATCH (this)-[:HAS]-(:Council)-[:LEADS]-(bishop:Member) RETURN bishop"
    )
  admin: Member @relationship(type: "IS_ADMIN_FOR", direction: IN)
  history: [HistoryLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  serviceRecord: [ServiceRecord]
    @relationship(type: "HAS_RECORD", direction: OUT)
  serviceLogs: [ServiceLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  services(limit: Int!): [ServiceRecord]
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(records:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      RETURN records ORDER BY date.date LIMIT $limit
      """
    )
  servicesThisWeek: [Fellowship]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowships:ActiveFellowship)
      WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week
        }
      RETURN fellowships
      """
    )
  servicesThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowships:ActiveFellowship)
      WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week
        }
      RETURN COUNT(fellowships)
      """
    )
  cancelledServicesThisWeek: [Fellowship]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowships:ActiveFellowship)
      WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week AND record.noServiceReason IS NOT NULL
        }
      RETURN fellowships
      """
    )
  cancelledServicesThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowships:ActiveFellowship)
      WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week AND record.noServiceReason IS NOT NULL
        }
      RETURN COUNT(fellowships)
      """
    )
  formDefaultersThisWeek: [Fellowship]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowships:ActiveFellowship)
      WHERE EXISTS {
             MATCH (fellowships)-[:MEETS_ON]->(day:ServiceDay)
             WHERE day.dayNumber < date().dayOfWeek OR  time() > time('20:30')
              }
              MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week <> date().week
      RETURN fellowships
      """
    )
  formDefaultersThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowships:ActiveFellowship)
      WHERE EXISTS {
             MATCH (fellowships)-[:MEETS_ON]->(day:ServiceDay)
             WHERE day.dayNumber < date().dayOfWeek OR  time() > time('20:30')
              }
              MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week <> date().week
      RETURN COUNT(fellowships)
      """
    )
  bankingDefaultersThisWeek: [Fellowship]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowships) WHERE fellowships:ActiveFellowship OR fellowships:ClosedFellowship
      MATCH (fellowships) WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week AND record.noServiceReason IS NULL AND record.bankingSlip IS NULL
        }
      RETURN fellowships
      """
    )
  bankingDefaultersThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowships) WHERE fellowships:ActiveFellowship OR fellowships:ClosedFellowship
      MATCH (fellowships) WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week AND record.noServiceReason IS NULL AND record.bankingSlip IS NULL
        }
      RETURN COUNT(fellowships)
      """
    )
  bankedThisWeek: [Fellowship]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowships) WHERE fellowships:ActiveFellowship OR fellowships:ClosedFellowship
      MATCH (fellowships) WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week AND record.noServiceReason IS NULL AND record.bankingSlip IS NOT NULL
        }
      RETURN fellowships
      """
    )
  bankedThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowships) WHERE fellowships:ActiveFellowship OR fellowships:ClosedFellowship
      MATCH (fellowships) WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week AND record.noServiceReason IS NULL AND record.bankingSlip IS NOT NULL
        }
      RETURN COUNT(fellowships)
      """
    )

  componentServiceAggregate: [ComponentServiceAggregate] @ignore
}

type Bacenta {
  id: ID @id
  name: String
  stream: String
    @cypher(
      statement: """
      MATCH (this)<-[:HAS*3]-(stream:Stream)
      RETURN DISTINCT toLower(stream.name)
      """
    )
  members: [Member]
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(fellowship:Fellowship)<-[:BELONGS_TO]-(members:Member)
      RETURN DISTINCT members
      """
    )
  memberCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(fellowship:Fellowship)<-[:BELONGS_TO]-(members:Member)
      RETURN COUNT(DISTINCT members)
      """
    )
  leader: Member @relationship(type: "LEADS", direction: IN)
  fellowships: [Fellowship] @relationship(type: "HAS", direction: OUT)
  basontas: Basonta @relationship(type: "HAS_BASONTA", direction: OUT)
  town: Town @relationship(type: "HAS", direction: IN)
  campus: Campus @relationship(type: "HAS", direction: IN)
  constituency: Constituency @relationship(type: "HAS", direction: IN)
  history: [HistoryLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  serviceLogs: [ServiceLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  services(limit: Int!): [ServiceRecord]
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(services:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      RETURN services ORDER BY date.date LIMIT $limit
      """
    )
  council: Council
    @cypher(
      statement: """
      MATCH (this)<-[:HAS*2]-(council:Council)
      RETURN council
      """
    )
  fellowshipServiceAggregate: [ComponentServiceAggregate] @ignore
}

# Shared Units: Fellowship, Fellowship, Sonta
type Fellowship {
  id: ID @id
  bankingCode: Int
  name: String
  location: Point
  stream: String
    @cypher(
      statement: """
      MATCH (this)<-[:HAS*4]-(stream:Stream)
      RETURN DISTINCT toLower(stream.name)
      """
    )
  bacenta: Bacenta @relationship(type: "HAS", direction: IN)
  leader: Member @relationship(type: "LEADS", direction: IN)
  members: [Member] @relationship(type: "BELONGS_TO", direction: IN)
  memberCount: Int
    @cypher(
      statement: """
      MATCH (this)<-[:BELONGS_TO]-(members:Member)
      RETURN COUNT(DISTINCT members)
      """
    )
  meetingDay: ServiceDay @relationship(type: "MEETS_ON", direction: OUT)
  history: [HistoryLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  serviceLogs: [ServiceLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  services(limit: Int!): [ServiceRecord]
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(services:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      RETURN services ORDER BY date.date LIMIT $limit
      """
    )
  labels: [String]
    @cypher(
      statement: """
      MATCH (this)
      RETURN labels(this)
      """
    )
  council: Council
    @cypher(
      statement: """
      MATCH (this)<-[:HAS*3]-(council:Council)
      RETURN council
      """
    )
}
type ClosedFellowship {
  id: ID @id
  bankingCode: Int
  name: String
  location: Point
  stream: String
    @cypher(
      statement: """
      MATCH (this)<-[:HAS*4]-(stream:Stream)
      RETURN DISTINCT toLower(stream.name)
      """
    )
  bacenta: Bacenta @relationship(type: "HAS", direction: IN)
  leader: Member @relationship(type: "LEADS", direction: IN)
  members: [Member] @relationship(type: "BELONGS_TO", direction: IN)
  memberCount: Int
    @cypher(
      statement: """
      MATCH (this)<-[:BELONGS_TO]-(members:Member)
      RETURN COUNT(DISTINCT members)
      """
    )
  meetingDay: ServiceDay @relationship(type: "MEETS_ON", direction: OUT)
  history: [HistoryLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  serviceLogs: [ServiceLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  services(limit: Int!): [ServiceRecord]
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(services:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      RETURN services ORDER BY date.date LIMIT $limit
      """
    )
  labels: [String]
    @cypher(
      statement: """
      MATCH (this)
      RETURN labels(this)
      """
    )
  council: Council
    @cypher(
      statement: """
      MATCH (this)<-[:HAS*3]-(council:Council)
      RETURN council
      """
    )
}

type ServiceDay @auth(rules: [{ isAuthenticated: true }]) {
  day: String!
  dayNumber: Int
  fellowship: Fellowship @relationship(type: "MEETS_ON", direction: IN)
}

type Ministry {
  id: ID @id
  name: String
  sonta: [Sonta] @relationship(type: "HAS_SONTA", direction: OUT)
  leader: Member @relationship(type: "LEADS", direction: IN)
  members: [Member] @relationship(type: "BELONGS_TO", direction: IN)
}

type Sonta {
  id: ID @id
  name: String
  stream: String
    @cypher(
      statement: """
      MATCH (this)<-[:HAS*4]-(stream:Stream)
      RETURN DISTINCT toLower(stream.name)
      """
    )
  leader: Member @relationship(type: "LEADS", direction: IN)
  basonta: [Basonta] @relationship(type: "HAS_BASONTA", direction: OUT)
  ministry: Ministry @relationship(type: "HAS_SONTA", direction: IN)
  town: Town @relationship(type: "HAS_SONTA", direction: IN)
  history: [HistoryLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  campus: Campus @relationship(type: "HAS_SONTA", direction: IN)
  serviceLogs: [ServiceLog] @relationship(type: "HAS_HISTORY", direction: OUT)
}
type Basonta {
  id: ID @id
  name: String
  leader: Member @relationship(type: "LEADS", direction: IN)
  bacenta: Bacenta @relationship(type: "HAS_BASONTA", direction: IN)
  sonta: Sonta @relationship(type: "HAS_BASONTA", direction: IN)
}

#Query Definitions
type Query {
  #At the Federal Level

  #At the Episcopal Level
  bishopCampusTownCount(id: ID): Int!
    @cypher(
      statement: "MATCH (:Member {id: $id})-[:HAS]->(campusTown) WHERE campusTown:Campus OR campusTown:Town RETURN COUNT(DISTINCT campusTown)"
    )
  bishopBacentaCount(id: ID): Int!
    @cypher(
      statement: "MATCH (:Member {id: $id})-[:HAS]->()-[:HAS]-(bacenta:Bacenta) RETURN COUNT(DISTINCT bacenta)"
    )
  bishopFellowshipCount(id: ID): Int!
    @cypher(
      statement: "MATCH (:Member {id: $id})-[:HAS]->()-[:HAS]->(:Bacenta)-[:HAS]-(fellowship:Fellowship) RETURN COUNT(DISTINCT fellowship)"
    )
  councilFellowshipDropdown(id: ID!, fellowshipName: String!): [Fellowship]
    @cypher(
      statement: "MATCH (council:Council {id:$id})-[:HAS*3]->(fellowship:Fellowship) WHERE toLower(fellowship.name) CONTAINS toLower($fellowshipName) RETURN DISTINCT fellowship LIMIT 5"
    )
  bishopsSontaMemberList(id: ID): [Member]!
    @cypher(
      statement: """
      MATCH (:Member {id: $id})-[:HAS]->()-[:HAS]->(:Bacenta)-[:HAS]->(:Fellowship)<-[:BELONGS_TO]-(member:Member)-[:BELONGS_TO]->(:Ministry)
      RETURN member
      """
    )
  bishopSontamembershipCount(id: ID): Int!
    @cypher(
      statement: """
      MATCH (:Member {id: $id})-[:HAS]->()-[:HAS]->(:Bacenta)-[:HAS]->(:Fellowship)<-[:BELONGS_TO]-(member:Member)-[:BELONGS_TO]->(:Ministry)
      RETURN COUNT(DISTINCT member)
      """
    )
  bishopSontamembershipCountList(bishopId: ID): [Ministry]!
    @cypher(
      statement: """
      MATCH (:Member {id: $bishopId})-[:HAS]->()-[:HAS]->(:Bacenta)-[:HAS]->(:Fellowship)<-[:BELONGS_TO]-(m:Member)-[:BELONGS_TO]->(ministry:Ministry)
      RETURN ministry, COUNT(DISTINCT member)
      """
    )
  bishopPastorCount(id: ID): Int!
    @cypher(
      statement: "MATCH (title:Title)<-[:HAS_TITLE]-(member:Member)-[:BELONGS_TO]->(:Fellowship)<-[:HAS]-(:Bacenta)-[:HAS]-()-[:HAS]-(:Member {id: $id}) RETURN COUNT( DISTINCT member)"
    )

  councilBacentaDropdown(id: ID!, nameSearch: String!): [Bacenta]
    @cypher(
      statement: """
      MATCH (:Council {id: $id})-[:HAS]->(campusTown) WHERE campusTown:Campus OR campusTown:Town
      MATCH (campusTown)-[:HAS]->(bacenta:Bacenta)
      WHERE toLower(bacenta.name) CONTAINS toLower($nameSearch)
      RETURN bacenta LIMIT 5
      """
    )

  councilMemberDropdown(id: ID!, nameSearch: String!): [Member]
    @cypher(
      statement: """
      MATCH (:Council {id: $id})-[:HAS]->(campusTown) WHERE campusTown:Town OR campusTown:Campus
      MATCH (campusTown)-[:HAS]->(:Bacenta)-[:HAS]->(:Fellowship)<-[:BELONGS_TO]-(member:Member)
      WHERE toLower(member.firstName+ ' ' + member.lastName) CONTAINS toLower($nameSearch)
      RETURN member LIMIT 5
      """
    )

  #At the Town Level
  townSontaList(id: ID): [Sonta]
    @cypher(
      statement: "MATCH (town:Town {id: $id})-[:HAS_SONTA]->(sonta:Sonta)  RETURN sonta"
    )
  townBacentaCount(id: ID): Int!
    @cypher(
      statement: "MATCH(:Town {id:$id})-[:HAS]->(bacenta:Bacenta) RETURN COUNT(bacenta)"
    )
  townSontaCount(id: ID): Int!
    @cypher(
      statement: "MATCH (:Town {id:$id})-[:HAS_SONTA]->(sonta:Sonta) RETURN COUNT(sonta)"
    )
  townSontamembershipCount(id: ID): Int!
    @cypher(
      statement: "MATCH (:Town {id: $id})-[]-(:Bacenta)-[]->(:Fellowship)<-[:BELONGS_TO]-(member:Member) MATCH (member)-[:BELONGS_TO]->(:Ministry) RETURN COUNT(DISTINCT member)"
    )

  #At the Campus Level
  campusFellowshipList(id: ID): [Fellowship]
    @cypher(
      statement: "MATCH (campus:Campus {id: $id})-[:HAS]->(:Bacenta)-[:HAS]-> (fellowship:Fellowship) RETURN fellowship"
    )
  campusSontaList(id: ID): [Sonta]
    @cypher(
      statement: "MATCH (campus:Campus {id: $id})-[:HAS_SONTA]->(sonta:Sonta)  RETURN sonta"
    )
  campusBacentaList(id: ID): [Bacenta]
    @cypher(
      statement: "MATCH (t:Campus {id:$id})-[:HAS]->(bacenta:Bacenta) RETURN bacenta"
    )
  campusBacentaCount(id: ID): Int!
    @cypher(
      statement: "MATCH(:Campus {id:$id})-[:HAS]->(bacenta:Bacenta) RETURN COUNT(bacenta)"
    )
  campusSontaCount(id: ID): Int!
    @cypher(
      statement: "MATCH (:Campus {id:$id})-[:HAS_MINISTRY]->(sonta:Sonta) RETURN COUNT(sonta)"
    )

  campusSontamembershipCount(id: ID): Int!
    @cypher(
      statement: "MATCH (:Campus {id: $id})-[]-(:Bacenta)-[]->(:Fellowship)<-[:BELONGS_TO]-(member:Member) MATCH (member)-[:BELONGS_TO]->(:Ministry) RETURN COUNT(DISTINCT member)"
    )

  #At the Bacenta Level
  bacentaDropdown(bacentaName: String): [Bacenta]
    @cypher(
      statement: "MATCH (bacenta:Bacenta) WHERE toLower(bacenta.name) CONTAINS toLower($bacentaName) RETURN bacenta LIMIT 5"
    )
  bacentaFellowshipList(id: ID): [Fellowship]
    @cypher(
      statement: """
      MATCH (fellowship:Fellowship)
      WHERE (:Bacenta {id:$id})-[:HAS]->(fellowship)
      RETURN fellowship
      """
    )
  bacentaFellowshipCount(id: ID): Int!
    @cypher(
      statement: "MATCH (:Bacenta {id:$id})-[:HAS]->(fellowship:Fellowship) RETURN COUNT(fellowship)"
    )
  bacentaSontaCount(id: ID): Int!
    @cypher(
      statement: "MATCH (sonta:Sonta)<-[:HAS_MINISTRY]-(:Bacenta {name:$bacenta}) RETURN COUNT(sonta)"
    )

  fellowshipDropdown(fellowshipName: String): [Fellowship]
    @cypher(
      statement: "MATCH (fellowship:Fellowship) WHERE toLower(fellowship.name) CONTAINS toLower($fellowshipName) RETURN DISTINCT fellowship LIMIT 5"
    )

  #At the Ministry Level
  sontaTownList(bishopId: ID, ministryId: ID): [Town]
    @cypher(
      statement: """
      MATCH (ministry:Ministry {id: $ministryId})<-[:BELONGS_TO]-(member:Member)
      MATCH (member)-[:BELONGS_TO]->(:Fellowship)<-[:HAS]-()<-[:HAS]-(campusTown)
      MATCH (campusTown)<-[:HAS|HAS]-(:Member {id: $bishopId})
      RETURN DISTINCT campusTown,ministry
      """
    )

  #At the Sonta Level
  sontaList: [Sonta] @cypher(statement: "MATCH (s:Sonta) RETURN s")
  townSontaLeader(bishopId: ID): [Member]
    @cypher(
      statement: """
      MATCH (ministry:Ministry)<-[:BELONGS_TO]-(member:Member)
      MATCH (member)-[:BELONGS_TO]->(:Fellowship)<-[:HAS]-()<-[:HAS]-(campusTown)
      MATCH (campusTown)<-[:HAS|HAS]-(:Member {id: $bishopId})
      MATCH (campusTown)-[:HAS_SONTA]->(s:Sonta {id:$sontaId})<-[:LEADS]-(sontaLeader:Member)
      WHERE sonta.name CONTAINS campusTown.name
         RETURN DISTINCT sontaLeader
      """
    )

  sontaBasontaLeaderList(id: ID): [Member]
    @cypher(
      statement: """
      MATCH (sonta:Sonta {id: $id})
      MATCH (basonta:Basonta)<-[:HAS_BASONTA]-(sonta)
      MATCH (basonta)<-[:LEADS]-(leader)
      RETURN leader
      """
    )

  #Members
  # Display Member based on ID
  currentUser(id: ID): Member
    @cypher(
      statement: "MATCH (member:Member {auth_id: $auth.jwt.sub}) RETURN member"
    )
    @auth(rules: [{ isAuthenticated: true }])

  memberByEmail(email: String!): Member
    @cypher(
      statement: "MATCH (member:Member {email:$email}) RETURN member LIMIT 1"
    )

  #DASHBOARD QUERIES

  #Fuzzy Search
  memberGridList(
    gender: String
    maritalStatus: String
    ministryId: ID
    leaderTitle: String
    leaderRank: String
  ): [Member]
    @cypher(
      statement: """
      MATCH (member:Member)
      WHERE (member)-[:HAS_GENDER]->(:Gender{gender:$gender})
      OR (member)-[:HAS_MARITAL_STATUS]->(:MaritalStatus{status:$maritalStatus})
      RETURN member
      """
    )

  federalMemberSearch(searchKey: String): [Member]
    @auth(rules: [{ roles: ["adminFederal"] }])
    @cypher(
      statement: """
      MATCH (member:Member)
      WHERE toLower(member.firstName) = toLower($searchKey)
      OR toLower(member.middleName) = toLower($searchKey)
      OR toLower(member.lastName) = toLower($searchKey)
      OR toLower(member.firstName) STARTS WITH toLower($searchKey)
      OR toLower(member.middleName) STARTS WITH toLower($searchKey)
      OR toLower(member.lastName) STARTS WITH toLower($searchKey)
      OR toLower(member.firstName + ' ' + member.middleName+ ' '+ member.lastName) CONTAINS toLower($searchKey)
      RETURN member LIMIT 5
      """
    )
  councilMemberSearch(searchKey: String, councilId: ID): [Member]
    @auth(rules: [{ roles: ["adminCouncil"] }])
    @cypher(
      statement: """
      MATCH (council:Council {id: $councilId})-[:HAS]->(campusTown)-[:HAS]->(:Bacenta)-[:HAS]->(:Fellowship)<-[:BELONGS_TO*]-(member:Member)
      WHERE toLower(member.firstName) = toLower($searchKey)
      OR toLower(member.lastName) = toLower($searchKey)
      OR toLower(member.firstName) STARTS WITH toLower($searchKey)
      OR toLower(member.lastName) STARTS WITH toLower($searchKey)
      OR toLower(member.firstName + ' ' + member.middleName+ ' '+ member.lastName) CONTAINS toLower($searchKey)
      WITH member WHERE member IS NOT NULL
      RETURN DISTINCT(member) LIMIT 5
      """
    )
  constituencyMemberSearch(searchKey: String, constituencyId: ID): [Member]
    @auth(rules: [{ roles: ["adminCampus", "adminTown"] }])
    @cypher(
      statement: """
      MATCH (constituency {id:$constituencyId}) WHERE constituency:Campus OR constituency:Town
      MATCH (constituency)-[:HAS]->(:Bacenta)-[:HAS]->(fellowship:Fellowship)<-[:BELONGS_TO]-(member:Member)
      WHERE toLower(member.firstName) = toLower($searchKey)
      OR toLower(member.lastName) = toLower($searchKey)
      OR toLower(member.firstName) STARTS WITH toLower($searchKey)
      OR toLower(member.lastName) STARTS WITH toLower($searchKey)
      OR toLower(member.firstName + ' ' + member.middleName+ ' '+ member.lastName) CONTAINS toLower($searchKey)

      RETURN member LIMIT 5
      """
    )
  bacentaMemberSearch(searchKey: String, bacentaId: ID): [Member]
    @auth(rules: [{ roles: ["leaderBacenta"] }])
    @cypher(
      statement: """
      MATCH (bacenta:Bacenta {id: $bacentaId})-[:HAS]->(:Fellowship)<-[:BELONGS_TO]-(member:Member)
      WHERE toLower(member.firstName) = toLower($searchKey)
      OR toLower(member.lastName) = toLower($searchKey)
      OR toLower(member.firstName) STARTS WITH toLower($searchKey)
      OR toLower(member.lastName) STARTS WITH toLower($searchKey)
      OR toLower(member.firstName + ' ' + member.middleName+ ' '+ member.lastName) CONTAINS toLower($searchKey)

      RETURN member LIMIT 5
      """
    )
  fellowshipMemberSearch(searchKey: String, fellowshipId: ID): [Member]
    @auth(rules: [{ roles: ["leaderFellowship"] }])
    @cypher(
      statement: """
      MATCH (fellowship:Fellowship {id: $fellowshipId})<-[:BELONGS_TO]-(member:Member)
      WHERE toLower(member.firstName) = toLower($searchKey)
      OR toLower(member.lastName) = toLower($searchKey)
      OR toLower(member.firstName) STARTS WITH toLower($searchKey)
      OR toLower(member.lastName) STARTS WITH toLower($searchKey)
      OR toLower(member.firstName + ' ' + member.middleName+ ' '+ member.lastName) CONTAINS toLower($searchKey)

      RETURN member LIMIT 5
      """
    )
  federalFellowshipSearch(searchKey: String): [Fellowship]
    @auth(rules: [{ roles: ["adminFederal"] }])
    @cypher(
      statement: """
      MATCH (fellowship:Fellowship)
      WHERE toLower(fellowship.name) STARTS WITH toLower($searchKey)
      OR toLower(fellowship.name) CONTAINS toLower($searchKey)
      RETURN DISTINCT fellowship LIMIT 5
      """
    )
  councilFellowshipSearch(searchKey: String, councilId: ID): [Fellowship]
    @auth(rules: [{ roles: ["adminCouncil"] }])
    @cypher(
      statement: """
      MATCH (council:Council {id: $councilId})-[:HAS*3]->(fellowship:Fellowship)

      WHERE toLower(fellowship.name) STARTS WITH toLower($searchKey)
      OR toLower(fellowship.name) CONTAINS toLower($searchKey)
      RETURN DISTINCT fellowship LIMIT 5
      """
    )
  constituencyFellowshipSearch(
    searchKey: String
    constituencyId: ID
  ): [Fellowship]
    @auth(rules: [{ roles: ["adminCampus", "adminTown"] }])
    @cypher(
      statement: """
      MATCH (constituency {id:$constituencyId})-[:HAS*2]->(fellowship:Fellowship)

      WHERE toLower(fellowship.name) STARTS WITH toLower($searchKey)
      OR toLower(fellowship.name) CONTAINS toLower($searchKey)
      RETURN DISTINCT fellowship LIMIT 5
      """
    )
  bacentaFellowshipSearch(searchKey: String, bacentaId: ID): [Fellowship]
    @auth(rules: [{ roles: ["leaderBacenta"] }])
    @cypher(
      statement: """
      MATCH (bacenta:Bacenta {id: $bacentaId})-[:HAS]->(fellowship:Fellowship)
      WHERE toLower(fellowship.name) STARTS WITH toLower($searchKey)
      OR toLower(fellowship.name) CONTAINS toLower($searchKey)
      RETURN DISTINCT fellowship LIMIT 5
      """
    )
  federalBacentaSearch(searchKey: String): [Bacenta]
    @auth(rules: [{ roles: ["adminFederal"] }])
    @cypher(
      statement: """
      MATCH (bacenta:Bacenta)
      WHERE toLower(bacenta.name) STARTS WITH toLower($searchKey)
      OR toLower(bacenta.name) CONTAINS toLower($searchKey)
      RETURN bacenta LIMIT 5
      """
    )
  councilBacentaSearch(searchKey: String, councilId: ID): [Bacenta]
    @auth(rules: [{ roles: ["adminCouncil"] }])
    @cypher(
      statement: """
      MATCH (council:Council {id: $councilId})-[:HAS*2]->(bacenta)

      WHERE toLower(bacenta.name) STARTS WITH toLower($searchKey)
      OR toLower(bacenta.name) CONTAINS toLower($searchKey)
      RETURN bacenta LIMIT 5
      """
    )
  constituencyBacentaSearch(
    searchKey: String
    constituencyId: ID
  ): [Fellowship]
    @auth(rules: [{ roles: ["adminCampus", "adminTown"] }])
    @cypher(
      statement: """
      MATCH (constituency {id:$constituencyId}) WHERE constituency:Campus OR constituency:Town
      MATCH (constituency)-[:HAS]->(bacenta)

      WHERE toLower(bacenta.name) STARTS WITH toLower($searchKey)
      OR toLower(bacenta.name) CONTAINS toLower($searchKey)
      RETURN bacenta LIMIT 5
      """
    )
  federalCampusSearch(searchKey: String): [Campus]
    @auth(rules: [{ roles: ["adminFederal"] }])
    @cypher(
      statement: """
      MATCH (campus:Campus)
      WHERE toLower(campus.name) STARTS WITH toLower($searchKey)
      OR toLower(campus.name) CONTAINS toLower($searchKey)
      RETURN campus LIMIT 5
      """
    )
  councilCampusSearch(searchKey: String, councilId: ID): [Campus]
    @auth(rules: [{ roles: ["adminCouncil"] }])
    @cypher(
      statement: """
      MATCH (council:Council {id: $councilId})-[:HAS]->(campus)

      WHERE toLower(campus.name) STARTS WITH toLower($searchKey)
      OR toLower(campus.name) CONTAINS toLower($searchKey)
      RETURN campus LIMIT 5
      """
    )
  federalTownSearch(searchKey: String): [Town]
    @auth(rules: [{ roles: ["adminFederal"] }])
    @cypher(
      statement: """
      MATCH (town:Town)
      WHERE toLower(town.name) STARTS WITH toLower($searchKey)
      OR toLower(town.name) CONTAINS toLower($searchKey)
      RETURN town LIMIT 5
      """
    )
  councilTownSearch(searchKey: String, councilId: ID): [Town]
    @auth(rules: [{ roles: ["adminCouncil"] }])
    @cypher(
      statement: """
      MATCH (council:Council {id: $councilId})-[:HAS]->(town)

      WHERE toLower(town.name) STARTS WITH toLower($searchKey)
      OR toLower(town.name) CONTAINS toLower($searchKey)
      RETURN town LIMIT 5
      """
    )
  federalSontaSearch(searchKey: String): [Sonta]
    @auth(rules: [{ roles: ["adminFederal"] }])
    @cypher(
      statement: """
      MATCH (sonta:Sonta)
      WHERE toLower(sonta.name) STARTS WITH toLower($searchKey)
      OR toLower(sonta.name) CONTAINS toLower($searchKey)
      RETURN sonta LIMIT 5
      """
    )
  councilSontaSearch(searchKey: String, councilId: ID): [Sonta]
    @auth(rules: [{ roles: ["adminCouncil"] }])
    @cypher(
      statement: """
      MATCH (council:Council {id: $councilId})-[:HAS]->(campusTown)
      MATCH (campusTown)-[:HAS_SONTA]->(sonta)

      WHERE toLower(sonta.name) STARTS WITH toLower($searchKey)
      OR toLower(sonta.name) CONTAINS toLower($searchKey)
      RETURN sonta LIMIT 5
      """
    )
  constituencySontaSearch(searchKey: String, constituencyId: ID): [Fellowship]
    @auth(rules: [{ roles: ["adminCampus", "adminTown"] }])
    @cypher(
      statement: """
      MATCH (constituency {id:$constituencyId}) WHERE constituency:Campus OR constituency:Town
      MATCH (constituency)-[:HAS_SONTA]->(sonta)

      WHERE toLower(sonta.name) STARTS WITH toLower($searchKey)
      OR toLower(sonta.name) CONTAINS toLower($searchKey)
      RETURN sonta LIMIT 5
      """
    )

  occupationList(searchKey: String!): [Occupation]
    @cypher(
      statement: "MATCH (occupation:Occupation) WHERE toLower(occupation.occupation) CONTAINS toLower($searchKey) RETURN occupation"
    )
}

#Mutation Definitions
type Mutation {
  #resolver Mutations
  MakeCouncilAdmin(adminId: ID!, councilId: ID!): Member
  RemoveCouncilAdmin(adminId: ID!, councilId: ID!): Member
  MakeTownAdmin(adminId: ID!, townId: ID!): Member
  RemoveTownAdmin(adminId: ID!, townId: ID!): Member
  MakeCampusAdmin(adminId: ID!, campusId: ID!): Member
  RemoveCampusAdmin(adminId: ID!, campusId: ID!): Member
  MakeFellowshipLeader(leaderId: ID!, fellowshipId: ID!): Member
  RemoveFellowshipLeader(leaderId: ID!, fellowshipId: ID!): Member
  MakeBacentaLeader(leaderId: ID!, bacentaId: ID!): Member
  RemoveBacentaLeader(leaderId: ID!, bacentaId: ID!): Member
  MakeSontaLeader(leaderId: ID!, sontaId: ID!): Member
  RemoveSontaLeader(leaderId: ID!, sontaId: ID!): Member
  MakeTownLeader(leaderId: ID!, townId: ID!): Member
  RemoveTownLeader(leaderId: ID!, townId: ID!): Member
  MakeCampusLeader(leaderId: ID!, campusId: ID!): Member
  RemoveCampusLeader(leaderId: ID!, campusId: ID!): Member

  #CREATE OPERATIONS
  # Add Member to the Database
  CreateMember(
    firstName: String!
    middleName: String
    lastName: String!
    email: String!
    phoneNumber: String!
    whatsappNumber: String!
    dob: String!
    maritalStatus: String!
    gender: String!
    occupation: String
    fellowship: String!
    ministry: String
    pictureUrl: String!
  ): Member

  CreateTown(
    townName: String!
    leaderId: ID!
    councilId: ID!
    bacentas: [ID]
  ): Town
    @auth(rules: [{ roles: ["adminFederal", "adminCouncil"] }])
    @cypher(
      statement: """
       CREATE (town:Town:Constituency {name:$townName})
         	SET
      	town.id = apoc.create.uuid()
      WITH town
      MATCH (leader:Member {id: $leaderId})
      MATCH (currentUser:Member {auth_id:$auth.jwt.sub})
      MATCH (council:Council {id: $councilId})

       CREATE (log:HistoryLog)
        SET
        log.id =  apoc.create.uuid(),
        log.timeStamp = datetime(),
        log.historyRecord = leader.firstName + ' ' +leader.lastName + ' started ' + $townName +' Town Church under '+ council.name+ ' Council'

      MERGE (council)-[:HAS]->(town)
      MERGE (leader)-[:LEADS]->(town)

      MERGE (date:TimeGraph {date: date()})
      MERGE (log)-[:LOGGED_BY]->(currentUser)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (council)-[:HAS_HISTORY]->(log)
      MERGE (town)-[:HAS_HISTORY]->(log)
      MERGE (leader)-[r:HAS_HISTORY]->(log)
        SET r.current = true

      WITH town, council
      CALL {
        WITH town
        WITH town WHERE $bacentas <> []
        UNWIND $bacentas AS bacentaIds
        MATCH (bacenta:Bacenta {id:bacentaIds})
        OPTIONAL MATCH (oldCampusTown)-[r:HAS]->(bacenta)
        DELETE r

        MERGE (town)-[:HAS]->(bacenta)
        RETURN count(town)
      }

      RETURN town
      """
    )
  CreateCampus(
    campusName: String!
    leaderId: ID!
    councilId: ID!
    bacentas: [ID]
  ): Campus
    @auth(rules: [{ roles: ["adminFederal", "adminCouncil"] }])
    @cypher(
      statement: """
      CREATE (campus:Campus:Constituency {name:$campusName})
         	SET
      	campus.id = apoc.create.uuid()
      WITH campus
      MATCH (leader:Member {id: $leaderId})
      MATCH (currentUser:Member {auth_id:$auth.jwt.sub})
      MATCH (council:Council {id: $councilId})

       CREATE (log:HistoryLog)
        SET
        log.id =  apoc.create.uuid(),
        log.timeStamp = datetime(),
        log.historyRecord = leader.firstName + ' ' +leader.lastName + ' started ' + $campusName +' Campus Church under '+ council.name+ ' Council'

      MERGE (council)-[:HAS]->(campus)
      MERGE (leader)-[:LEADS]->(campus)

      MERGE (date:TimeGraph {date: date()})
      MERGE (log)-[:LOGGED_BY]->(currentUser)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (council)-[:HAS_HISTORY]->(log)
      MERGE (campus)-[:HAS_HISTORY]->(log)
      MERGE (leader)-[r:HAS_HISTORY]->(log)
        SET r.current = true

      WITH campus, council
      CALL {
        WITH campus
        WITH campus WHERE $bacentas <> []
        UNWIND $bacentas AS bacentaIds
        MATCH (bacenta:Bacenta {id:bacentaIds})
        OPTIONAL MATCH (oldCampusTown)-[r:HAS]->(bacenta)
        DELETE r

        MERGE (campus)-[:HAS]->(bacenta)
        RETURN count(campus)
      }

      RETURN campus
      """
    )

  CreateBacenta(
    bacentaName: String!
    townCampusId: ID!
    leaderId: ID!
    fellowships: [ID]
  ): Bacenta  #Return town and drill down to get bacenta info
    @auth(
      rules: [
        { roles: ["adminFederal", "adminCouncil", "adminCampus", "adminTown"] }
      ]
    )
    @cypher(
      statement: """
      CREATE (bacenta:Bacenta {name:$bacentaName})
         	SET
      	bacenta.id = apoc.create.uuid()
      WITH bacenta
       MATCH (leader:Member {id:$leaderId})
       MATCH (campusTown {id:$townCampusId}) WHERE campusTown:Town OR campusTown:Campus
       MATCH (currentUser:Member {auth_id:$auth.jwt.sub})
       UNWIND labels(campusTown) AS stream

      CREATE (log:HistoryLog:ServiceLog)
      SET log.id = apoc.create.uuid(),
       log.timeStamp = datetime(),
       log.historyRecord = leader.firstName + ' ' +leader.lastName + ' started ' + bacenta.name +' Bacenta under '+ campusTown.name + ' ' + stream

       MERGE (campusTown)-[:HAS]->(bacenta)
       MERGE (leader)-[:LEADS]->(bacenta)

       MERGE (date:TimeGraph {date: date()})
       MERGE (log)-[:LOGGED_BY]->(currentUser)
       MERGE (log)-[:RECORDED_ON]->(date)
       MERGE (campusTown)-[:HAS_HISTORY]->(log)
       MERGE (bacenta)-[:HAS_HISTORY]->(log)
       MERGE (leader)-[r:HAS_HISTORY]->(log)
        SET r.current = true

       WITH bacenta
      CALL {
        WITH bacenta
        WITH bacenta WHERE $fellowships <> []
        UNWIND $fellowships AS fellowshipIds
        MATCH (fellowship:Fellowship {id:fellowshipIds})
        OPTIONAL MATCH (oldBacenta)-[r:HAS]->(fellowship)
        DELETE r

        MERGE (bacenta)-[:HAS]->(fellowship)
        RETURN count(bacenta)
      }

      RETURN bacenta
      """
    )
  CreateSonta(ministryId: ID!, townCampusId: ID!, leaderId: ID!): Town
    @auth(
      rules: [
        { roles: ["adminFederal", "adminCouncil", "adminCampus", "adminTown"] }
      ]
    )
    @cypher(
      statement: """
      CREATE (sonta:Sonta)
         	SET
      	sonta.id = apoc.create.uuid()
      WITH sonta
       MATCH (ministry:Ministry {id:$ministryId})
       MATCH (leader:Member {id: $leaderId})
       MATCH (campusTown {id:$townCampusId}) WHERE campusTown:Town OR campusTown:Campus

       MATCH (currentUser:Member {auth_id:$auth.jwt.sub})
       UNWIND labels(campusTown) AS stream

       CREATE (log:HistoryLog:ServiceLog)
        SET log.id = apoc.create.uuid(),
         log.timeStamp = datetime(),
         log.historyRecord = leader.firstName + ' ' +leader.lastName + ' started ' + sonta.name +' Sonta under '+ campusTown.name + ' ' + stream


       SET sonta.name = campusTown.name + ' ' + ministry.name

       MERGE (ministry)-[:HAS_SONTA]->(sonta)
       MERGE (campusTown)-[:HAS_SONTA]->(sonta)
       MERGE (leader)-[:LEADS]->(sonta)

      MERGE (date:TimeGraph {date: date()})
      MERGE (log)-[:LOGGED_BY]->(currentUser)
       MERGE (log)-[:RECORDED_ON]->(date)
       MERGE (campusTown)-[:HAS_HISTORY]->(log)
       MERGE (sonta)-[:HAS_HISTORY]->(log)
       MERGE (leader)-[r:HAS_HISTORY]->(log)
        SET r.current = true

      RETURN campusTown
      """
    )
  CreateFellowship(
    fellowshipName: String!
    bacentaId: ID!
    leaderId: ID!
    meetingDay: String!
    venueLongitude: Float
    venueLatitude: Float
  ): Fellowship
    @auth(
      rules: [
        { roles: ["adminFederal", "adminCouncil", "adminCampus", "adminTown"] }
      ]
    )
    @cypher(
      statement: """
      MATCH (lastCode:LastBankingCode)
      CREATE (fellowship:Fellowship:ActiveFellowship {name:$fellowshipName,location: point({latitude:toFloat($venueLatitude), longitude:toFloat($venueLongitude), crs:'WGS-84'})})
         	SET
      	fellowship.id = apoc.create.uuid(),
        fellowship.bankingCode = lastCode.number + 1,
        lastCode.number = fellowship.bankingCode

      WITH fellowship
      MATCH (bacenta:Bacenta {id: $bacentaId})
      MATCH (leader:Member {id:$leaderId})
      MATCH (currentUser:Member {auth_id:$auth.jwt.sub})
      MATCH (meetingDay:ServiceDay {day: $meetingDay})

      MERGE (bacenta)-[:HAS]->(fellowship)
      MERGE (leader)-[r:LEADS]->(fellowship)
      MERGE (fellowship)-[:MEETS_ON]->(meetingDay)
        SET r.current = true

      RETURN fellowship
      """
    )

  #UPDATE OPERATIONS
  UpdateMemberDetails(
    id: ID!
    firstName: String!
    middleName: String
    lastName: String!
    email: String
    phoneNumber: String!
    whatsappNumber: String
    dob: String
    maritalStatus: String!
    gender: String!
    occupation: String
    fellowship: String!
    ministry: String
    pictureUrl: String!
  ): Member
    @auth(
      rules: [
        {
          roles: [
            "adminFederal"
            "adminCouncil"
            "adminCampus"
            "adminTown"
            "leaderFellowship"
            "leaderBacenta"
            "leaderCampus"
            "leaderTown"
          ]
        }
      ]
    )
    @cypher(
      statement: """
      MATCH (member:Member {id:$id})
      SET
      	member.firstName = $firstName,
      	member.middleName = $middleName,
      	member.lastName = $lastName,
      	member.email = $email,
      	member.phoneNumber = $phoneNumber,
        member.whatsappNumber = $whatsappNumber,
      	member.pictureUrl = $pictureUrl

      WITH member

      MATCH (gender:Gender {gender: $gender})
      MERGE (member)-[:HAS_GENDER]-> (gender)


      WITH member
         CALL {
         	WITH member
         	WITH member  WHERE $dob IS NOT NULL
         	MERGE (date:TimeGraph {date: date($dob)})
      	WITH member,date
      	OPTIONAL MATCH (member)-[r1:WAS_BORN_ON]->()
      	DELETE r1
      	MERGE (member)-[:WAS_BORN_ON]->(date)
         	RETURN count(member)
         	}

      WITH member
         CALL {
         	WITH member
         	WITH member  WHERE $maritalStatus IS NOT NULL
         	MATCH (maritalStatus:MaritalStatus {status:$maritalStatus})
      	OPTIONAL MATCH (member)-[r1:HAS_MARITAL_STATUS]->()
      	DELETE r1
      	MERGE (member)-[:HAS_MARITAL_STATUS]-> (maritalStatus)
         	RETURN count(member)
         	}

         WITH member
         CALL {
         	WITH member
         	WITH member  WHERE $occupation IS NOT NULL
      	OPTIONAL MATCH (member)-[r1:HAS_OCCUPATION]-> ()
        MERGE (occupation:Occupation {occupation:$occupation})
      	DELETE r1
      	MERGE (member)-[:HAS_OCCUPATION]-> (occupation)
         	RETURN count(member)
         	}
      WITH member
      CALL {
         	WITH member
         	WITH member  WHERE $fellowship IS NOT NULL
         	MATCH (fellowship:Fellowship {id: $fellowship})
      	OPTIONAL MATCH (member)-[r0:BELONGS_TO]-> (:Fellowship)
      	DELETE r0
      	MERGE (member)-[:BELONGS_TO]-> (fellowship)
         	RETURN count(member)
         	}
      WITH member
      CALL {
         	WITH member
         	WITH member  WHERE $ministry IS NOT NULL
         	MATCH (ministry:Ministry {id:$ministry})
      	OPTIONAL MATCH (member)-[r0:BELONGS_TO]-> (:Ministry)
      	DELETE r0
      	MERGE (member)-[:BELONGS_TO]-> (ministry)
         	RETURN count(member)
         	}

      RETURN member
      """
    )

  UpdateTownDetails(townId: ID!, townName: String!, councilId: ID!): Town
    @auth(rules: [{ roles: ["adminFederal", "adminCouncil"] }])
    @cypher(
      statement: """
      MATCH (town:Town {id: $townId})
      	SET town.name = $townName

      WITH town
         CALL {
         	WITH town
          MATCH (council:Council {id: $councilId})
          OPTIONAL MATCH (town)<-[r:HAS]-()
          DELETE r
          MERGE (council)-[:HAS]->(town)
         	RETURN count(town)
         	}

      MATCH (town)<-[:LEADS]-(leader:Member)
      RETURN town
      """
    )
  UpdateCampusDetails(
    campusId: ID!
    campusName: String!
    councilId: ID!
  ): Campus
    @auth(rules: [{ roles: ["adminFederal", "adminCouncil"] }])
    @cypher(
      statement: """
           MATCH (campus:Campus {id: $campusId})
           	SET campus.name = $campusName

           WITH campus
              CALL {
              	WITH campus

                  MATCH (council:Council {id: $councilId})
                  OPTIONAL MATCH (campus)<-[r:HAS]-()
                  DELETE r
                  MERGE (council)-[:HAS]->(campus)
              	RETURN count(campus)
              	}
      MATCH (campus)<-[:LEADS]-(leader:Member)
      RETURN campus
      """
    )
  UpdateBacentaDetails(
    bacentaId: ID!
    bacentaName: String!
    campusTownId: ID!
  ): Bacenta
    @auth(
      rules: [
        { roles: ["adminFederal", "adminCouncil", "adminCampus", "adminTown"] }
      ]
    )
    @cypher(
      statement: """
      MATCH (bacenta:Bacenta {id: $bacentaId})
      	SET bacenta.name = $bacentaName

      WITH bacenta
         CALL {
         	WITH bacenta
      		OPTIONAL MATCH (campusTown {id: $campusTownId}) WHERE campusTown:Campus OR campusTown:Town

            OPTIONAL MATCH (bacenta)<-[r:HAS]-()
            DELETE r
            MERGE (campusTown)-[:HAS]->(bacenta)
         	RETURN count(bacenta)
         	}
      MATCH (bacenta)<-[:LEADS]-(leader:Member)
      RETURN bacenta
      """
    )

  UpdateSontaDetails(sontaId: ID!, sontaName: String!): Sonta
    @auth(
      rules: [
        { roles: ["adminFederal", "adminCouncil", "adminCampus", "adminTown"] }
      ]
    )
    @cypher(
      statement: """
      MATCH (sonta:Sonta {id: $sontaId})
      	SET sonta.name = $sontaName

      WITH sonta
      MATCH (sonta)<-[:LEADS]-(leader:Member)
      RETURN sonta
      """
    )

  UpdateFellowshipDetails(
    id: ID!
    name: String!
    meetingDay: String
    venueLongitude: Float
    venueLatitude: Float
  ): Fellowship
    @auth(
      rules: [
        { roles: ["adminFederal", "adminCouncil", "adminCampus", "adminTown"] }
      ]
    )
    @cypher(
      statement: """
               MATCH (fellowship:Fellowship {id: $id})
               	SET fellowship.name = $name
              	SET fellowship.location = point({latitude:toFloat($venueLatitude), longitude:toFloat($venueLongitude), crs:'WGS-84'})

               WITH fellowship
                    CALL {
                     	WITH fellowship
                      WITH fellowship WHERE $meetingDay IS NOT NULL
                      MATCH (meetingDay:ServiceDay {day: $meetingDay})
                      OPTIONAL MATCH (fellowship)-[r:MEETS_ON]->()
                      DELETE r
                      MERGE (fellowship)-[:MEETS_ON]->(meetingDay)
                     	RETURN count(fellowship)
                     	}

      RETURN fellowship
      """
    )
  #DIFFERENT LOG HISTORY MUTATIONS
  ConnectChurchHistory(churchId: ID!): [ServiceLog]
    @cypher(
      statement: """
      MATCH (church {id: $churchId})
      WHERE church:Bacenta OR church:Town OR church:Campus OR church:Sonta
      MATCH (church)-[r:HAS_HISTORY]->(churchHistory:ServiceLog) WHERE r.current=true
      MATCH (church)-[:HAS]->(downRelatedChurch)
      MATCH (upRelatedChurch)-[:HAS]->(church)
      MATCH (downRelatedChurch)-[r1:HAS_HISTORY]->(downHistory:ServiceLog) WHERE r1.current=true
      MATCH (upRelatedChurch)-[r2:HAS_HISTORY]->(upHistory:ServiceLog) WHERE r2.current=true

      MERGE (upHistory)-[:HAS]->(churchHistory)
      MERGE (churchHistory)-[:HAS]->(downHistory)

      RETURN churchHistory
      """
    )

  ConnectFellowshipHistory(churchId: ID!): [ServiceLog]
    @cypher(
      statement: """
      MATCH (church:Fellowship {id: $churchId})
      MATCH (church)-[r:HAS_HISTORY]->(churchHistory:ServiceLog) WHERE r.current=true
      MATCH (upRelatedChurch)-[:HAS]->(church)
      MATCH (upRelatedChurch)-[r2:HAS_HISTORY]->(upHistory:ServiceLog) WHERE r2.current=true

      MERGE (upHistory)-[:HAS]->(churchHistory)

      RETURN churchHistory
      """
    )
  ConnectCouncilHistory(churchId: ID!): [ServiceLog]
    @cypher(
      statement: """
      MATCH (church:Council {id: $churchId})
      MATCH (church)-[r:HAS_HISTORY]-(churchHistory:ServiceLog) WHERE r.current=true
      MATCH (downRelatedChurch)-[:HAS]->(church)
      MATCH (downRelatedChurch)-[r2:HAS_HISTORY]->(downHistory:ServiceLog) WHERE r2.current=true

      MERGE (churchHistory)-[:HAS]->(downHistory)

      RETURN churchHistory
      """
    )

  LogFellowshipHistory(
    fellowshipId: ID!
    historyRecord: String!
    oldLeaderId: ID
    newLeaderId: ID
    oldBacentaId: ID
    newBacentaId: ID
  ): Fellowship
    @cypher(
      statement: """
      MATCH  (fellowship:Fellowship {id: $fellowshipId})
      MATCH (admin:Member {auth_id: $auth.jwt.sub})
      CREATE (log:HistoryLog {id: apoc.create.uuid()})
        SET log.historyRecord = $historyRecord,
          log.timeStamp = datetime()
      MERGE (date:TimeGraph {date: date()})
      MERGE (fellowship)-[r:HAS_HISTORY]->(log)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (log)-[:LOGGED_BY]->(admin)


      WITH log,fellowship
      CALL{
        WITH log
        WITH log WHERE $oldBacentaId IS NOT NULL
        MATCH (oldBacenta:Bacenta {id: $oldBacentaId})
        MERGE (oldBacenta)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      WITH log,fellowship
      CALL{
        WITH log
        WITH log WHERE $newBacentaId IS NOT NULL
        MATCH (newBacenta:Bacenta {id: $newBacentaId})
        MERGE (newBacenta)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      RETURN fellowship
      """
    )
  LogBacentaHistory(
    bacentaId: ID!
    historyRecord: String!
    newLeaderId: ID
    oldLeaderId: ID
    newCampusTownId: ID
    oldCampusTownId: ID
  ): Bacenta
    @cypher(
      statement: """
       MATCH  (bacenta:Bacenta {id: $bacentaId})
       MATCH (admin:Member {auth_id: $auth.jwt.sub})
       CREATE (log:HistoryLog {id: apoc.create.uuid()})
         SET log.historyRecord = $historyRecord,
           log.timeStamp = datetime()
       MERGE (date:TimeGraph {date: date()})
       MERGE (bacenta)-[r:HAS_HISTORY]->(log)
       MERGE (log)-[:RECORDED_ON]->(date)
        MERGE (log)-[:LOGGED_BY]->(admin)

       WITH log,bacenta
       CALL{
         WITH log
         WITH log WHERE $newLeaderId IS NOT NULL
       MATCH (newLeader:Member {id: $newLeaderId})
      OPTIONAL MATCH (oldLeader:Member {id: $oldLeaderId})
         SET log :ServiceLog
         WITH log, newLeader,oldLeader
       OPTIONAl MATCH (log)<-[r0:HAS_HISTORY]-()
         SET r0.current = false
         WITH log,newLeader,oldLeader
       CREATE (oldLeader)-[:HAS_HISTORY]->(log)
       CREATE (newLeader)-[r:HAS_HISTORY]->(log)
          SET r.current = true
          WITH log
       RETURN COUNT(log)
       }


       WITH log,bacenta
       CALL {
         WITH log
         WITH log WHERE $oldCampusTownId IS NOT NULL
         MATCH (oldCampusTown {id: $oldCampusTownId}) WHERE oldCampusTown:Town OR oldCampusTown:Campus
         MERGE (oldCampusTown)-[:HAS_HISTORY]->(log)
         RETURN COUNT(log)
       }

       WITH log,bacenta
       CALL {
         WITH log
         WITH log WHERE $newCampusTownId IS NOT NULL
         MATCH (newCampusTown {id: $newCampusTownId}) WHERE newCampusTown:Town OR newCampusTown:Campus
         MERGE (newCampusTown)-[:HAS_HISTORY]->(log)
         RETURN COUNT(log)
       }

       RETURN bacenta
      """
    )
  LogCampusTownHistory(
    campusTownId: ID!
    historyRecord: String!
    newLeaderId: ID
    oldLeaderId: ID
    newCouncilId: ID
    oldCouncilId: ID
  ): Constituency
    @cypher(
      statement: """
      MATCH  (campusTown {id: $campusTownId}) WHERE campusTown:Campus OR campusTown:Town
      MATCH (admin:Member {auth_id: $auth.jwt.sub})
      CREATE (log:HistoryLog {id: apoc.create.uuid()})
        SET log.historyRecord = $historyRecord,
          log.timeStamp = datetime()
      MERGE (date:TimeGraph {date: date()})
      MERGE (campusTown)-[r:HAS_HISTORY]->(log)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (log)-[:LOGGED_BY]->(admin)

      WITH log,campusTown
      CALL{
        WITH log
        WITH log WHERE $newLeaderId IS NOT NULL
      MATCH (newLeader:Member {id: $newLeaderId})
        SET log :ServiceLog
        WITH log, newLeader
      OPTIONAl MATCH ()-[r0:HAS_HISTORY]->(log)
        SET r0.current = false
        WITH log,newLeader
      CREATE (newLeader)-[r:HAS_HISTORY]->(log)
         SET r.current = true
         WITH log
      RETURN COUNT(log)
      }

      WITH log,campusTown
      CALL {
        WITH log
        WITH log WHERE $oldLeaderId IS NOT NULL
        MATCH (oldLeader:Member {id: $oldLeaderId})
        CREATE (oldLeader)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }


      WITH log,campusTown
      CALL {
        WITH log
        WITH log WHERE $oldCouncilId IS NOT NULL
        MATCH (council:Council {id: $oldCouncilId})
        MERGE (council)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      WITH log,campusTown
      CALL {
        WITH log
        WITH log WHERE $newCouncilId IS NOT NULL
        MATCH (council:Council {id: $newCouncilId})
        MERGE (council)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      RETURN campusTown
      """
    )

  LogCouncilHistory(
    councilId: ID!
    historyRecord: String!
    newLeaderId: ID
    oldLeaderId: ID
    newGatheringServiceId: ID
    oldGatheringServiceId: ID
  ): Council
    @cypher(
      statement: """
      MATCH  (council:Council {id: $councilId})
      MATCH (admin:Member {auth_id: $auth.jwt.sub})
      CREATE (log:HistoryLog {id: apoc.create.uuid()})
        SET log.historyRecord = $historyRecord,
          log.timeStamp = datetime()
      MERGE (date:TimeGraph {date: date()})
      MERGE (council)-[r:HAS_HISTORY]->(log)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (log)-[:LOGGED_BY]->(admin)

      WITH log,council
      CALL{
        WITH log
        WITH log WHERE $newLeaderId IS NOT NULL
      MATCH (newLeader:Member {id: $newLeaderId})
        SET log :ServiceLog
        WITH log, newLeader
      OPTIONAl MATCH ()-[r0:HAS_HISTORY]->(log)
        SET r0.current = false
        WITH log,newLeader
      CREATE (newLeader)-[r:HAS_HISTORY]->(log)
         SET r.current = true
         WITH log
      RETURN COUNT(log)
      }

      WITH log,council
      CALL {
        WITH log
        WITH log WHERE $oldLeaderId IS NOT NULL
        MATCH (oldLeader:Member {id: $oldLeaderId})
        CREATE (oldLeader)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }


      WITH log,council
      CALL {
        WITH log
        WITH log WHERE $oldGatheringServiceId IS NOT NULL
        MATCH (council:Council {id: $oldGatheringServiceId})
        MERGE (council)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      WITH log,council
      CALL {
        WITH log
        WITH log WHERE $newGatheringServiceId IS NOT NULL
        MATCH (council:Council {id: $newGatheringServiceId})
        MERGE (council)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      RETURN council
      """
    )

  LogSontaHistory(
    sontaId: ID!
    historyRecord: String!
    newLeaderId: ID
    oldLeaderId: ID
  ): Sonta
    @cypher(
      statement: """
       MATCH  (sonta:Sonta {id: $sontaId})
       MATCH (admin:Member {auth_id: $auth.jwt.sub})
       CREATE (log:HistoryLog {id: apoc.create.uuid()})
         SET log.historyRecord = $historyRecord,
           log.timeStamp = datetime()
       MERGE (date:TimeGraph {date: date()})
       MERGE (sonta)-[r:HAS_HISTORY]->(log)
       MERGE (log)-[:RECORDED_ON]->(date)
       MERGE (log)-[:LOGGED_BY]->(admin)

       WITH log,sonta
       CALL{
         WITH log
         WITH log WHERE $newLeaderId IS NOT NULL
       MATCH (newLeader:Member {id: $newLeaderId})
      OPTIONAL MATCH (oldLeader:Member {id: $oldLeaderId})
         SET log :ServiceLog
         WITH log, newLeader,oldLeader
       OPTIONAl MATCH ()-[r0:HAS_HISTORY]->(log)
         SET r0.current = false
         WITH log,newLeader,oldLeader
       CREATE (oldLeader)-[:HAS_HISTORY]->(log)
       CREATE (newLeader)-[r:HAS_HISTORY]->(log)
          SET r.current = true
          WITH log
       RETURN COUNT(log)
       }


       RETURN sonta
      """
    )

  #SERVICE RECORDS MUTATIONS
  RecordService(
    id: ID!
    serviceDate: String!
    attendance: Int!
    income: Float!
    foreignCurrency: String
    numberOfTithers: Int
    treasurers: [ID]!
    treasurerSelfie: String!
    servicePicture: String!
  ): ServiceRecord
    @cypher(
      statement: """
      CREATE (serviceRecord:ServiceRecord {created_at:datetime()})
        SET serviceRecord.id = apoc.create.uuid(),
        serviceRecord.attendance = $attendance,
        serviceRecord.income = $income,
        serviceRecord.foreignCurrency = $foreignCurrency,
        serviceRecord.numberOfTithers = $numberOfTithers,
        serviceRecord.treasurerSelfie = $treasurerSelfie,
        serviceRecord.servicePicture = $servicePicture
      WITH serviceRecord
      MATCH (church {id:$id}) WHERE church:Fellowship OR church:Bacenta OR church:Campus OR church:Town
      MATCH (church)-[has_history:HAS_HISTORY]->(log:HistoryLog) WHERE has_history.current = true
      MATCH (leader:Member {auth_id: $auth.jwt.sub})

      MERGE (serviceRecord)-[:LOGGED_BY]->(leader)
      MERGE (serviceDate:TimeGraph {date:date($serviceDate)})
      MERGE (serviceRecord)-[:SERVICE_HELD_ON]->(serviceDate)
      MERGE (log)-[:HAS_RECORD]->(serviceRecord)

      WITH serviceRecord
      UNWIND $treasurers AS treasurerId WITH treasurerId, serviceRecord
      MATCH (treasurer:Member {id: treasurerId})
      MERGE (treasurer)-[:WAS_TREASURER_FOR]->(serviceRecord)

      RETURN serviceRecord
      """
    )

  RecordCancelledService(
    id: ID!
    serviceDate: String!
    noServiceReason: String!
  ): NoService
    @cypher(
      statement: """
      CREATE (serviceRecord:ServiceRecord:NoService {created_at:datetime()})
        SET serviceRecord.id = apoc.create.uuid(),
        serviceRecord.noServiceReason = $noServiceReason

      WITH serviceRecord
      MATCH (church {id:$id}) WHERE church:Fellowship OR church:Bacenta OR church:Campus OR church:Town
      MATCH (church)-[has_history:HAS_HISTORY]->(log:HistoryLog) WHERE has_history.current = true
      MATCH (leader:Member {auth_id: $auth.jwt.sub})

      MERGE (serviceRecord)-[:LOGGED_BY]->(leader)
      MERGE (serviceDate:TimeGraph {date:date($serviceDate)})
      MERGE (serviceRecord)-[:SERVICE_HELD_ON]->(serviceDate)
      MERGE (log)-[:HAS_RECORD]->(serviceRecord)

      RETURN serviceRecord
      """
    )

  RecordServiceNoOffering(
    id: ID!
    serviceDate: String!
    attendance: Int!
    servicePicture: String!
  ): ServiceRecord
    @cypher(
      statement: """
      CREATE (serviceRecord:ServiceRecord {created_at:datetime()})
        SET serviceRecord.id = apoc.create.uuid(),
        serviceRecord.attendance = $attendance,
        serviceRecord.servicePicture = $servicePicture
      WITH serviceRecord
      MATCH (church {id:$id}) WHERE church:Fellowship OR church:Bacenta OR church:Sonta OR church:Campus OR church:Town
      MATCH (church)-[has_history:HAS_HISTORY]->(log:HistoryLog) WHERE has_history.current = true
      MATCH (leader:Member {auth_id: $auth.jwt.sub})

      MERGE (serviceRecord)-[:LOGGED_BY]->(leader)
      MERGE (serviceDate:TimeGraph {date:date($serviceDate)})
      MERGE (serviceRecord)-[:SERVICE_HELD_ON]->(serviceDate)
      MERGE (log)-[:HAS_RECORD]->(serviceRecord)

      RETURN serviceRecord
      """
    )

  #Set Fellowship to be 'OnVacation
  SetVacationFellowship(fellowshipId: ID!): Fellowship
    @cypher(
      statement: """
      MATCH (fellowship:Fellowship {id:$fellowshipId})

      CREATE (log:HistoryLog {id:apoc.create.uuid()})
        SET log.timeStamp = datetime(),
        log.historyRecord = fellowship.name + ' Fellowship went on vacation mode'

      WITH log,fellowship
      MATCH (admin:Member {auth_id: $auth.jwt.sub})
      MERGE (date:TimeGraph {date:date()})
      MERGE (log)-[:LOGGED_BY]->(admin)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (fellowship)-[:HAS_HISTORY]->(log)
      MERGE (bacenta)-[:HAS_HISTORY]->(log)

      SET fellowship:Vacation
      REMOVE fellowship:ActiveFellowship

      RETURN fellowship
      """
    )

  #DELETE OPERATIONS
  # In the context of church data we never delete, we only render inactive
  CloseDownFellowship(fellowshipId: ID!): Fellowship
  CloseDownBacenta(bacentaId: ID!): Bacenta
    @cypher(
      statement: """
      MATCH (bacenta:Bacenta {id:$bacentaId})
      MATCH (admin:Member {auth_id: $auth.jwt.sub})
      OPTIONAL MATCH (bacenta)-[:HAS]-(campusTown)
      OPTIONAL MATCH (bacenta)-[:HAS]->(fellowships)
      UNWIND labels(campusTown) AS stream

      CREATE (log:HistoryLog {id:apoc.create.uuid()})
        SET log.timeStamp = datetime(),
        log.historyRecord = bacenta.name + ' Bacenta was closed down under ' + campusTown.name +' '+stream


      MERGE (date:TimeGraph {date:date()})
      MERGE (log)-[:LOGGED_BY]->(admin)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (bacenta)-[:HAS_HISTORY]->(log)
      MERGE (campusTown)-[:HAS_HISTORY]->(log)

      SET bacenta:ClosedBacenta, fellowships:ClosedFellowship
      REMOVE bacenta:Bacenta,  fellowships:Fellowship


      RETURN bacenta
      """
    )

  CloseDownCampusTown(campusTownId: ID!): Constituency
    @cypher(
      statement: """
      MATCH (campusTown {id:$campusTownId}) WHERE campusTown:Campus OR campusTown:Town
      MATCH (admin:Member {auth_id: $auth.jwt.sub})
      MATCH (campusTown)-[:HAS]-(council:Council)
      OPTIONAL MATCH (campusTown)-[:HAS]->(bacentas)-[:HAS]->(fellowships)
      UNWIND labels(campusTown) AS stream

      CREATE (log:HistoryLog {id:apoc.create.uuid()})
        SET log.timeStamp = datetime(),
        log.historyRecord = campusTown.name + ' '+stream +' was closed down under ' + council.name +' Council'


      MERGE (date:TimeGraph {date:date()})
      MERGE (log)-[:LOGGED_BY]->(admin)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (council)-[:HAS_HISTORY]->(log)
      MERGE (bishop)-[:HAS_HISTORY]->(log)

      SET campusTown:ClosedCampusTown, bacentas:ClosedBacenta, fellowships:ClosedFellowship
      REMOVE campusTown:Campus:Town,bacentas:Bacenta,fellowships:Fellowship

      RETURN campusTown
      """
    )

  #CHURCH CONVERSIONS
  MakeFellowshipIntoBacenta(fellowshipId: ID!): Bacenta
    @cypher(
      statement: """
      MATCH (fellowship:Fellowship {id:$fellowshipId})
      MATCH (admin:Member {auth_id: $auth.jwt.sub})
      CREATE (newFellowship:Fellowship {id:apoc.create.uuid()})
       SET newFellowship.name = fellowship.name,
       newFellowship.location = fellowship.location
      CREATE (log:HistoryLog {id:apoc.create.uuid()})
        SET log.timeStamp = datetime(),
        log.historyRecord = fellowship.name + ' was made into a Bacenta with '+ newFellowship.name+' as a fellowship under it.'

      WITH newFellowship, log, fellowship
      MATCH (fellowship)<-[hasFellowship:HAS]-(:Bacenta)<-[:HAS]-(campusTown)
      MATCH (fellowship)-[meetsOnDay:MEETS_ON]->(meetingDay)
      MATCH (fellowship)<-[belongsTo:BELONGS_TO]-(member:Member)
      MATCH (fellowship)<-[:LEADS]-(leader:Member)

      MERGE (date:TimeGraph {date:date()})
      MERGE (campusTown)-[:HAS]->(fellowship)
      MERGE (newFellowship)-[:MEETS_ON]->(meetingDay)
      MERGE (newFellowship)<-[:LEADS]-(leader)
      MERGE (member)-[:BELONGS_TO]->(newFellowship)
      MERGE (fellowship)-[:HAS]->(newFellowship)

      DELETE hasFellowship,meetsOnDay,belongsTo

      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (log)-[:LOGGED_BY]->(admin)
      MERGE (fellowship)-[:HAS_HISTORY]->(log)
      MERGE (newFellowship)-[:HAS_HISTORY]->(log)

      SET fellowship:Bacenta
      REMOVE fellowship.location
      REMOVE fellowship:Fellowship
      RETURN fellowship
      """
    )
}
