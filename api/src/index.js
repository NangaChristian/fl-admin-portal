import { typeDefs } from './graphql-schema'
import { ApolloServer, SchemaDirectiveVisitor} from 'apollo-server-express'
import express from 'express'
import neo4j from 'neo4j-driver'
import { makeAugmentedSchema, assertSchema } from 'neo4j-graphql-js'
import dotenv from 'dotenv'
import { initializeDatabase } from './initialize'
import { resolvers } from './resolvers'
import jwt from 'express-jwt'

// set environment variables from .env
dotenv.config()

const app = express()

/*
 * Create an executable GraphQL schema object from GraphQL type definitions
 * including autogenerated queries and mutations.
 * Optionally a config object can be included to specify which types to include
 * in generated queries and/or mutations. Read more in the docs:
 * https://grandstack.io/docs/neo4j-graphql-js-api.html#makeaugmentedschemaoptions-graphqlschema
 */

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object)
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object)
    if (enumerableOnly)
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable
      })
    keys.push.apply(keys, symbols)
  }
  return keys
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true,
    })
  } else {
    obj[key] = value
  }
  return obj
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {}
    if (i % 2) {
      ownKeys(source, true).forEach(function (key) {
        _defineProperty(target, key, source[key])
      })
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source))
    } else {
      ownKeys(source).forEach(function (key) {
        Object.defineProperty(
          target,
          key,
          Object.getOwnPropertyDescriptor(source, key)
        )
      })
    }
  }
  return target
}

class MyHasScopeDirective extends SchemaDirectiveVisitor {
  visitFieldDefinition(field) {
    var expectedScopes = this.args.scopes
    var next = field.resolve // wrap resolver with auth check

    field.resolve = function (result, args, context, info) {
      console.log(
        'Field name ' +
          field.name +
          ' VFD - looking for scope ' +
          expectedScopes
      )

      // var decoded = verifyAndDecodeToken({
      //   context: context,
      // }) // FIXME: override with env var

      var scopes =
        decoded['permissions'] ||
        decoded['Permissions'] ||
        decoded['Scopes'] ||
        decoded['scopes'] ||
        decoded['Scope'] ||
        decoded['scope'] ||
        []

      // if any requested scope matches
      if (
        expectedScopes.some(function (scope) {
          return scopes.indexOf(scope) !== -1
        }) ||
        expectedScopes.some(function (scope) {
          return scopes.indexOf('[' + field.name + ']') !== -1
        })
      ) {
        return next(
          result,
          args,
          _objectSpread({}, context, {
            user: decoded,
          }),
          info
        )
      }

      throw new _errors.AuthorizationError({
        message: 'You are not authorized for this resource',
      })
    }
  }
  visitObject(obj) {
    var fields = obj.getFields()
    var expectedScopes = this.args.scopes

    Object.keys(fields).forEach(function (fieldName) {
      var field = fields[fieldName]
      var next = field.resolve

      field.resolve = function (result, args, context, info) {
        console.log(
          'Field name ' +
            field.name +
            ' VFD - looking for scope ' +
            expectedScopes
        )

        // var decoded = verifyAndDecodeToken({
        //   context: context,
        // }) // FIXME: override w/ env var

        var scopes =
          decoded['permissions'] ||
          decoded['Permissions'] ||
          decoded['Scopes'] ||
          decoded['scopes'] ||
          decoded['Scope'] ||
          decoded['scope'] ||
          []

        if (
          expectedScopes.some(function (role) {
            return scopes.indexOf(role) !== -1
          })
        ) {
          return next(
            result,
            args,
            _objectSpread({}, context, {
              user: decoded,
            }),
            info
          )
        }

        throw new _errors.AuthorizationError({
          message: 'You are not authorized for this resource',
        })
      }
    })
  }
}

const schema = makeAugmentedSchema({
  typeDefs,
  resolvers,
  config: {
    query: true,
    mutation: true,
    auth: {
      isAuthenticated: true,
      hasScope: true,
    },
  },
  schemaDirectives: { hasScope: MyHasScopeDirective },
})

/*
 * Create a Neo4j driver instance to connect to the database
 * using credentials specified as environment variables
 * with fallback to defaults
 */

const driver = neo4j.driver(
  process.env.NEO4J_URI || 'bolt://localhost:7687',
  neo4j.auth.basic(
    process.env.NEO4J_USER || 'jd_addy',
    process.env.NEO4J_PASSWORD || 'letmein'
  ),
  {
    encrypted: process.env.NEO4J_ENCRYPTED ? 'ENCRYPTION_ON' : 'ENCRYPTION_OFF',
  }
)

assertSchema({ schema, driver, debug: true })

/*
 * Perform any database initialization steps such as
 * creating constraints or ensuring indexes are online
 *
 */
const init = async (driver) => {
  await initializeDatabase(driver)
}

/*
 * We catch any errors that occur during initialization
 * to handle cases where we still want the API to start
 * regardless, such as running with a read only user.
 * In this case, ensure that any desired initialization steps
 * have occurred
 */

init(driver)

/*
 * Create a new ApolloServer instance, serving the GraphQL schema
 * created using makeAugmentedSchema above and injecting the Neo4j driver
 * instance into the context object so it is available in the
 * generated resolvers to connect to the database.
 */
const server = new ApolloServer({
  context: ({ req }) => {
    return {
      req,
      driver,
      cypherParams: {
        user_authId: req?.user?.sub,
      },
      neo4jDatabase: process.env.NEO4J_DATABASE,
    }
  },
  schema: schema,
  introspection: true,
  playground: true,
})

// Specify host, port and path for GraphQL endpoint
const port = process.env.GRAPHQL_SERVER_PORT || 4001
const path = process.env.GRAPHQL_SERVER_PATH || '/graphql'
const host = process.env.GRAPHQL_SERVER_HOST || '0.0.0.0'

app.use(
  jwt({
    secret: process.env.JWT_SECRET.replace(/\\n/gm, '\n'),
    algorithms: ['RS256'],
    credentialsRequired: false,
  })
)

/*
 * Optionally, apply Express middleware for authentication, etc
 * This also also allows us to specify a path for the GraphQL endpoint
 */

server.applyMiddleware({ app, path })

app.listen({ host, port, path }, () => {
  // eslint-disable-next-line
  console.log(`GraphQL server ready at http://${host}:${port}${path}`)
})
